---
title: "Take Home Exercise 02"
description: |
  Analysing and Visualising the distribution of Airbnb listings in 2019 and 2021, and how Covid-19 affected the distribution.
author:
  - name: Kwek Yi Chen
    url: https://example.com/kwekyichen
date: 09-16-2021
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_float: true
    number_sections: true
    code_folding: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# 1 Introduction

Singapore is one of the global city that has yet to legalise short-term rentals offered by platforms such as Airbnb. However, there are data sets of Airbnb in Singapore, and they can be found from the Inside Airbnb website (http://insideairbnb.com/about.html). Hence, we are interested to analyse Airbnb in Singapore.

This analysis consist of two sections:

1) Section A: Airbnb Distribution in 2019

2) Section B: Impact of COVID-19

# 2 Data

- Airbnb Listings (June 2019 & July 2021) is the Airbnb Listing in Singapore for the year 2019 and 2021. It is in csv format, and can be taken from http://insideairbnb.com/get-the-data.html
- Hotels data  is the list of hotels in Singapore. It is in csv format, and can be extracted from SLA OneMap Service using onemapsapi.
- Tourist Attractions data is the list of tourist attractions in Singapore. It is in csv format, and can be extracted from SLA OneMap Service using onemapsapi.
- MrtLrtStnPtt contains all the Mrt and Lrt stations in Singapore. It is in ESRI shapefile format, and can be taken from https://datamall.lta.gov.sg/
- MP14_SUBZONE_WEB_PL is URA 2014 Master Plan Planning Subzone boundary data. It is in ESRI shapefile format, and can be taken from https://www.data.gov.sg/.
- CostalOutline is the national boundary of Singapore. It is in ESRI shapefile format, and can taken from SLA website.

# 3 Setting Up the Environment

The following code chunk install the following packages:

- maptools to convert Spatial objects into ppp format
- sf to handle geospatial data
- raster to convert image output generate by spatstat into raster format.
- spatstat to perform 1st and 2nd-order spatial point patterns analysis and derive kernel density estimation (KDE) layer
- tmap to create choropleth maps
- tidyr to tidy messy data
- readr to import csv
- osmdata to get bounding box of a given location name
- tmaptools to read open street map data
- ggplot2, ggtheme and plotly to plot interactive Cross-L map

```{r}
packages = c('maptools', 'sf', 'raster','spatstat', 'tmap', 'tidyr', 'readr', 'osmdata', 'tmaptools', 'ggplot2', 'ggthemes', 'plotly')
for (p in packages){
  if(!require(p, character.only = T)){
    install.packages(p)
  }
  library(p,character.only = T)
}
```


# 4 Spatial Data Wrangling

## 4.1 Importing Geospatial Data 

### 4.1.1 MrtLrt

#### 4.1.1.1 Importing

The following code uses st_read function of sf package to import MrtLrt geospatial data sets.

```{r}
mrtlrt_sf <- st_read(dsn = "data/geospatial", layer="MRTLRTStnPtt")
```

The MrtLrt data have 185 features with 3 fields. The projected CRS is SVY21. The geometry type is point. 

#### 4.1.1.2 Check CRS

Next, we use st_crs function of sf package to check the CRS.

```{r}
st_crs(mrtlrt_sf)
```

From the result above, even though the mrtlrt_sf is projected in svy21, the last line indicates that the EPSG is 9001. It is wrong because the correct EPSG code for svy21 should be 3414.

#### 4.1.1.3 Assign EPSG code to a simple feature data frame

The following code chunk will assign the correct EPSG code to mrtlrt_sf using st_set_crs function of sf package

```{r}
mrtlrt_sf <- st_set_crs(mrtlrt_sf, 3414)
```

Now that we have assign the correct EPSG code to mrtlrt_sf, we will check the CRS again using st_crs function of sf

#### 4.1.1.4 Check CRS again

```{r}
st_crs(mrtlrt_sf)
```

From the result above, we have successfully assign EPSG 3414 to mrtlrt_sf.

### 4.1.2 CostalOutline

#### 4.1.2.1 Importing

The following code uses st_read function of sf package to import CostalOutline geospatial data sets.

```{r}
sg_sf <- st_read(dsn = "data/geospatial", layer="CostalOutline")
```

The CostalOutline data have 60 features with 4 fields. The projected CRS is SVY21. The geometry type is polygon.

#### 4.1.2.2 Check CRS

Next, we use st_crs function of sf package to check the CRS.

```{r}
st_crs(sg_sf)
```

Similarly, even though the sg_sf is projected in svy21, the last line indicates that the EPSG is 9001. It is wrong because the correct EPSG code for svy21 should be 3414.

#### 4.1.2.3 Assign EPSG code to a simple feature data frame

The following code chunk will assign the correct EPSG code to sg_sf using st_set_crs function of sf package

```{r}
sg_sf <- st_set_crs(sg_sf, 3414)
```

Now that we have assign the correct EPSG code to sg_sf, we will check the CRS again using st_crs function of sf

#### 4.1.2.4 Check CRS again

```{r}
st_crs(sg_sf)
```
We have successfully set the EPSG to 3414 for sg_sf.

### 4.1.3 MPSZ

#### 4.1.3.1 Importing

The following code uses st_read function of sf package to import MP14_SUBZONE_WEB_PL geospatial data sets.

```{r}
mpsz_sf <- st_read(dsn = "data/geospatial", layer = "MP14_SUBZONE_WEB_PL")
```

The mpsz data have 323 features with 15 fields. The projected CRS is SVY21. The geometry type is multipolygon.

#### 4.1.3.2 Check CRS

Next, we use st_crs function of sf package to check the CRS.

```{r}
st_crs(mpsz_sf)
```

Similarly, even though the mpsz_sf is projected in svy21, the last line indicates that the EPSG is 9001. It is wrong because the correct EPSG code for svy21 should be 3414.

#### 4.1.3.3 Assign EPSG code to a simple feature data frame

The following code chunk will assign the correct EPSG code to mpsz_sf using st_set_crs function of sf package

```{r}
mpsz_sf <- st_set_crs(mpsz_sf, 3414)
```

Now that we have assign the correct EPSG code to mpsz_sf, we will check the CRS again using st_crs function of sf

#### 4.1.3.4 Check CRS again

```{r}
st_crs(mpsz_sf)
```

We have successfully assign ESPG 3414 to mpsz_sf.

## 4.2 Importing Aspatial Data 

### 4.2.1 Hotel

#### 4.2.1.1 Importing

The following code uses read_csv function of readr package to import Hotel aspatial data sets.

```{r}
hotels <- read_csv("data/aspatial/hotels.csv")
```

#### 4.2.1.2 Examine the file

The following code uses list function of base R to examine the imported file

```{r}
list(hotels)
```

The data contains 422 rows and 9 columns. There are 'Lat' and 'Lng' column for coordinates. They are in decimal degree format, hence we will assume the data is wgs84.

We will next check if there are any NA value in 'Lat' and 'Lng' using is.na function of base R package.

```{r}
any(is.na(hotels$Lat))
```

```{r}
any(is.na(hotels$Lng))
```

We can confirmed that there are no NA values and we can proceed to create a simple feature data frame.

#### 4.2.1.3 Create simple feature data frame from aspatial data

The following code chunk

1. convert hotels data  into simple feature data frame using st_as_sf feature of sf package.

2. 'Lng' and 'Lat' column are set as the coords arguments.

3. CRS were set as 4326 since we assumed that the data is wgs84

4. st_transform function of sf package then helps to transform the newly created simple feature data frame into svy21

5. tm_shape and tm_dots function of tmap plots the transformed hotels_sf

```{r}
hotels_sf <- st_as_sf(hotels,
                    coords = c("Lng", 
                               "Lat"),
                    crs=4326) %>%
  st_transform(crs = 3414)

tm_shape(hotels_sf)+
  tm_dots()
```

### 4.2.2 Tourism

#### 4.2.2.1 Importing

The following code uses read_csv function of readr package to import Tourism aspatial data sets.

```{r}
tourism <- read_csv("data/aspatial/tourism.csv")
```

#### 4.2.2.2 Examine the file

The following code uses list function of base R to examine the imported file

```{r}
list(tourism)
```

The tourism data contains 107 rows and 17 columns. There are 'LATITUDE' and 'LONGTITUDE' column, as well as 'Lat' and 'Lng' coluumn for coordinates. We will be using 'LATITUDE' and 'LONGTITUDE' column since they are the same. They are in decimal degree format, hence we will assume the data is wgs84.

We will next check if there are any NA value in 'LATITUDE' and 'LONGTITUDE' using is.na function of base R package.

```{r}
any(is.na(tourism$LATITUDE))
```

```{r}
any(is.na(tourism$LATITUDE))
```

There are NA values and we will need to drop them before creating a simple feature data frame.

The following code chunk drop rows of data as long as the LATITUDE is NA.

```{r}
tourism <- tourism %>%
            drop_na("LATITUDE")
```


#### 4.2.2.3 Create simple feature data frame from aspatial data

The following code chunk is similar to the previous when we convert hotels aspatial data to sf. The 'LONGTITUDE' and 'LATITUDE' column are set as the coords arguments.

```{r}

tourism_sf <- st_as_sf(tourism,
                    coords = c("LONGTITUDE", 
                               "LATITUDE"),
                    crs=4326) %>%
  st_transform(crs = 3414)

tm_shape(tourism_sf)+
  tm_dots()
```

### 4.2.3 Airbnb0619

#### 4.2.3.1 Importing

The following code uses read_csv function of readr package to import Airbnb listings30062019.csv aspatial data sets.

```{r}
airbnb0619 <- read_csv("data/aspatial/listings30062019.csv")
```

#### 4.2.3.2 Examine the file

The following code uses list function of base R to examine the imported file

```{r}
list(airbnb0619)
```

The airbnb0619 data contains 8293 rows and 16 columns. There are 'latitude' and 'longitude' column for coordinates. They are in decimal degree format, hence we will assume the data is wgs84.

We will next check if there are any NA value in 'latitude' and 'longitude' using is.na function of base R package.

```{r}
any(is.na(airbnb0619$latitude))
```

```{r}
any(is.na(airbnb0619$longitude))
```

Since there are no NA values, we can proceed to create simple features data frame for airbnb0619

#### 4.2.3.3 Create simple feature data frame from aspatial data

The following code chunk is similar to the previous when we convert hotels aspatial data to sf. The 'longitude' and 'latitude' column are set as the coords arguments.

```{r}
airbnb0619_sf <- st_as_sf(airbnb0619,
                    coords = c("longitude", 
                               "latitude"),
                    crs=4326) %>%
  st_transform(crs = 3414)

tm_shape(airbnb0619_sf)+
  tm_dots()
```

### 4.2.4 Airbnb0721

#### 4.2.4.1 Importing

The following code uses read_csv function of readr package to import Airbnb listings19072021.csv aspatial data sets.

```{r}
airbnb0721 <- read_csv("data/aspatial/listings19072021.csv")
```

#### 4.2.4.2 Examine the file

The following code uses list function of base R to examine the imported file

```{r}
list(airbnb0721)
```

The airbnb0721 data contains 4252 rows and 16 columns, lesser than airbnb0619. There are 'latitude' and 'longitude' column for coordinates. They are in decimal degree format, hence we will assume the data is wgs84.

We will next check if there are any NA value in 'latitude' and 'longitude' using is.na function of base R package.

```{r}
any(is.na(airbnb0721$latitude))
```

```{r}
any(is.na(airbnb0721$longitude))
```

We can confirm that there are no latitude and longitude with NA value.

#### 4.2.4.3 Create simple feature data frame from aspatial data

The following code chunk is similar to the previous when we convert hotels aspatial data to sf. The 'longitude' and 'latitude' column are set as the coords arguments.

```{r}
airbnb0721_sf <- st_as_sf(airbnb0721,
                    coords = c("longitude", 
                               "latitude"),
                    crs=4326) %>%
  st_transform(crs = 3414)

tm_shape(airbnb0721_sf)+
  tm_dots()
```

## 4.3 Geospatial Data wrangling

After importing geospatial and aspatial data, we will convert the simple feature data frame to sp’s Spatial* class.

### 4.3.1 Converting sf data frames to sp’s Spatial* class

The following code chunk converts all the geospatial data from simple feature data frame to sp’s Spatial* class using as_Spatial functions of sf package.

```{r}
airbnb0619 <- as_Spatial(airbnb0619_sf)
airbnb0721 <- as_Spatial(airbnb0721_sf)
hotels <- as_Spatial(hotels_sf)
tourism <- as_Spatial(tourism_sf)
mrtlrt <- as_Spatial(mrtlrt_sf)
sg <- as_Spatial(sg_sf)
mpsz <- as_Spatial(mpsz_sf)
```

Check each Spatial* class

```{r}
airbnb0619
```

```{r}
airbnb0721
```

```{r}
hotels
```

```{r}
tourism
```

```{r}
mrtlrt
```

```{r}
sg
```

```{r}
mpsz
```

We can see that all the geospatial data are converted to their respective Spatial* Classes.

### 4.3.2 Converting the Spatial* class into generic sp format

Next, we will convert Spatial* classes into Spatial object so that we can convert it into ppp object.

The following code chunk converts Spatial* classes into generic sp format using as function which sets the classes to their respective sp format. 

```{r}
airbnb0619_sp <- as(airbnb0619, "SpatialPoints")
airbnb0721_sp <- as(airbnb0721, "SpatialPoints")
hotels_sp <- as(hotels, "SpatialPoints")
tourism_sp <- as(tourism, "SpatialPoints")
mrtlrt_sp <- as(mrtlrt, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
mpsz_sp <- as(mpsz, "SpatialPolygons")
```

### 4.3.3 Converting the generic sp format into spatstat’s ppp format

We will next convert the spatial data into spatstat's ppp format.

The following code chunk converts spatial data into spatstat's ppp format using as function. 

```{r}
airbnb0619_ppp <- as(airbnb0619_sp, "ppp")
airbnb0721_ppp <- as(airbnb0721_sp, "ppp")
hotels_ppp <- as(hotels_sp, "ppp")
tourism_ppp <- as(tourism_sp, "ppp")
mrtlrt_ppp <- as(mrtlrt_sp, "ppp")
```

### 4.3.4 Handling duplicates in ppp object

#### 4.3.4.1 Check for dupliciates duplicates in each ppp object

The following code chunk use any and duplicated function of base R package to check for duplicates, and sum up the count of duplicated points using sum function of base R package and multiplicity function of spatstat package.

```{r}
any(duplicated(airbnb0619_ppp))
sum(multiplicity(airbnb0619_ppp) > 1)
```

From the result above, there are 6 duplicates in airbnb0619_ppp object. 

```{r}
any(duplicated(airbnb0721_ppp))
sum(multiplicity(airbnb0721_ppp) > 1)
```

From the result above, there are 224 duplicates in airbnb0721_ppp object. 

```{r}
any(duplicated(hotels_ppp))
sum(multiplicity(hotels_ppp) > 1)
```

From the result above, there are 10 duplicates in hotels_ppp object.

```{r}
any(duplicated(tourism_ppp))
sum(multiplicity(tourism_ppp) > 1)
```

From the result above, there are 7 duplicates in tourism_ppp object.

```{r}
any(duplicated(mrtlrt_ppp))
sum(multiplicity(mrtlrt_ppp) > 1)
```

From the result above, there are no duplicate in mrtlrt_ppp object.

#### 4.3.4.2 Handling duplicates

We will use jittering to handle duplicates so that we will not lose useful points. Jittering adds a small perturbation to the duplicated points so that they do not occupy the exact same space.

The following code chunk uses rjitter function of spatstat to jitter the ppp object with duplicates.

```{r}
airbnb0619_ppp_jit <- rjitter(airbnb0619_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

airbnb0721_ppp_jit <- rjitter(airbnb0721_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

hotels_ppp_jit <- rjitter(hotels_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

tourism_ppp_jit <- rjitter(tourism_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

#### 4.3.4.3 Check if duplicates still exist

```{r}
any(duplicated(airbnb0619_ppp_jit))
sum(multiplicity(airbnb0619_ppp_jit) > 1)
```

```{r}
any(duplicated(airbnb0721_ppp_jit))
sum(multiplicity(airbnb0721_ppp_jit) > 1)
```

```{r}
any(duplicated(hotels_ppp_jit))
sum(multiplicity(hotels_ppp_jit) > 1)
```

```{r}
any(duplicated(tourism_ppp_jit))
sum(multiplicity(tourism_ppp_jit) > 1)
```

We can confirm that there are no duplicated points after jittering.

### 4.3.5 Create owin objects

We will next create owin object to represent the Singapore boundary.

The following code chunk converts sg SpatialPolygon objects into owin object of spatstat using as function. 

```{r}
sg_owin <- as(sg_sp, "owin")
```

The following code chunk plots sg_owin using plot function of base R package.

```{r}
plot(sg_owin)
```

### 4.3.6 Combining point events object and owin object

The following code chunk combines the point objects of airbnb0619, airbnb0721, hotels, tourism and mrtlrt with the owin object into one ppp object class.

```{r}
airbnb0619SG_ppp = airbnb0619_ppp_jit[sg_owin]
airbnb0721SG_ppp = airbnb0721_ppp_jit[sg_owin]
hotelsSG_ppp = hotels_ppp_jit[sg_owin]
tourismSG_ppp = tourism_ppp_jit[sg_owin]
mrtlrtSG_ppp = mrtlrt_ppp[sg_owin]
```

The following code chunk plots the ppp object class using plot function of base R package.

```{r}
plot(airbnb0619SG_ppp)
```

```{r}
plot(airbnb0721SG_ppp)
```

```{r}
plot(hotelsSG_ppp)
```

```{r}
plot(tourismSG_ppp)
```

```{r}
plot(mrtlrtSG_ppp)
```

# 5 Section A: Airbnb Distribution in 2019

## 5.1 Exploratory Spatial Data Analysis

### 5.1.1 Kernel density maps

#### 5.1.1.1 Airbnb0619 listings

##### 5.1.1.1.1 Compute kernel density estimation with automatic bandwidth selection method

1. The following code chunk computes kernel density using density function of spatstat package.

2. The code first takes in the ppp object variable.

3. bw.diggle automatic bandwidth method to detect a tight cluster

4. smoothing kernel is set to default gaussian method 

```{r}
kde_airbnb0619SG_bw <- density(airbnb0619SG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")
```

The following code chunk plots the kde_airbnb0619SG_bw using plot function of base R

```{r}
plot(kde_airbnb0619SG_bw)
```

The density values of the output range is too small because the default unit of measurement of svy21 is in meter. As a result, the density values computed is in “number of units per square meter”.

##### 5.1.1.1.2 Rescalling KDE values

The following code chunk rescale the KDE value of airbnb0619SG_ppp using rescale function of spatstat from meter to kilometer.

```{r}
airbnb0619SG_ppp.km <- rescale(airbnb0619SG_ppp, 1000, "km")
```

##### 5.1.1.1.3 Different automatic bandwidth methods

The following code chunk calculate the bandwidth using different methods

```{r}
bw.CvL(airbnb0619SG_ppp.km)
```

```{r}
bw.scott(airbnb0619SG_ppp.km)
```

```{r}
bw.ppl(airbnb0619SG_ppp.km)
```

```{r}
bw.diggle(airbnb0619SG_ppp.km)
```

From the result above, bw.diggle has the lowest sigma compared to other methods. We will be using bw.diggle in this analysis in order to detect close cluster.

##### 5.1.1.1.4 KDE Map and Point Map in km

1. The following code chunk computes kernel density using density function of spatstat package.

2. The code first takes in the ppp object variable in km.

3. bw.diggle automatic bandwidth method to detect a tight cluster

4. smoothing kernel is set to default gaussian method

5. plot function of base R package and par function of graphics package is used to plot kde map and ppp point map side by side

```{r}
kde_airbnb0619SG_bw.km <- density(airbnb0619SG_ppp.km,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")


par(mfrow=c(1,2))
plot(kde_airbnb0619SG_bw.km, main = "KDE Map")
plot(airbnb0619SG_ppp.km, main = "Point Map")
```

Analysis: From the kde map above, we can see that the south-east region near the central area have higher density of Airbnb in 2019 as shown by the pink spots on kde map and the black patches on the point map. The kde map better visualised the density as compared to the point map because it uses different colour tone to represent the density. For example, purple means no/low number of units per square kilometer, pink represents medium density of about 1000 units per square kilometer, and yellow means high density of about 1500 units per square kilometer. The point map on the other hand cannot determine if an area is denser than the other area since it is only represented in one colour tone, black, and black patches can be seen almost every where in the point map.

##### 5.1.1.1.5 Convert KDE output into grid object in km

The following code chunk converts KDE output into grid object using as.SpatialGridDataFrame.im function of maptools, and plot the grid object using spplot function of raster package.


```{r}
gridded_kde_airbnb0619SG_bw.km <- as.SpatialGridDataFrame.im(kde_airbnb0619SG_bw.km)
spplot(gridded_kde_airbnb0619SG_bw.km)
```

Analysis: The above density map shows a clearer visualization of the density of Airbnb in 2019 using grid. We can see that the Airbnb are scattered all around as seen by the lighter blue grid on the map. The south-east area near the central have higher density with around 500 - 1500 units per square kilometer, represented by the brighter blue, pink-orange grid on the map.

##### 5.1.1.1.6 Convert grid object into raster

The following code chunk converts grid object into raster using raster function of raster package. Note that we will be using kde_airbnb0619SG_bw in m.

```{r}
gridded_kde_airbnb0619SG_bw <- as.SpatialGridDataFrame.im(kde_airbnb0619SG_bw)
kde_airbnb0619SG_bw_raster <- raster(gridded_kde_airbnb0619SG_bw)
kde_airbnb0619SG_bw_raster
```

From the result above, the crs is NA.

##### 5.1.1.1.7 Assign project system and plot raster on osm

1. The following code chunk first assign CRS to kde_airbnb0619SG_bw_raster 

2. Plot the raster on OpenstreetMap basemap in interactive mode

3. tmap_mode is set to view to plot interative map

4. tm_shape is the raster layer

5. tm_raster with setting of alpha = 0.7 makes the raster layer slightly transparent so that the basemap can be seen, palette set to Purples

6. tm_basemap is set to OpenStreetMap

7. tmap_mode change back to plot

```{r}
projection(kde_airbnb0619SG_bw_raster) <- CRS("+init=EPSG:3414")
kde_airbnb0619SG_bw_raster

tmap_mode("view")
tm_shape(kde_airbnb0619SG_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7) +
  tm_basemap("OpenStreetMap")

tmap_mode("plot")
```

Analysis: From the raster map, we can see that areas such as Geylang, Chinatown and Anson have the higher density of Airbnb with 0.0010 to 0.0020 units per square meter, as shown by the darker purple grid on the map. There are other areas such as Kallang have medium density of 0.0005 to 0.0010 units per square meter. We will look into these regions later.

#### 5.1.1.2 Hotels

##### 5.1.1.2.1 Rescale KDE values

The following code chunk rescale the KDE value of hotelsSG_ppp using rescale function of spatstat from meter to kilometer.

```{r}
hotelsSG_ppp.km <- rescale(hotelsSG_ppp, 1000, "km")
```

##### 5.1.1.2.2 KDE Map and Point Map in km

The following code chunk is similar to Airbnb0619's code chunk (5.1.1.1.4).

```{r}
kde_hotelsSG_bw.km <- density(hotelsSG_ppp.km,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

par(mfrow=c(1,2))
plot(kde_hotelsSG_bw.km, main = "KDE Map")
plot(hotelsSG_ppp.km, main="Point Map")
```

Analysis: From the kde map above, we can see that the south-east region near the central area have higher density of hotels of about 100 units per square kilometer, as shown by the pink orange spots on kde map. The black patches on the point map also concentrates around the south-east region near the central area.

##### 5.1.1.2.3 Convert KDE output into grid object in km

The following code chunk converts KDE output into grid object using as.SpatialGridDataFrame.im function of maptools, and plot the grid object using spplot function of raster package.

```{r}
gridded_kde_hotelsSG_bw.km <- as.SpatialGridDataFrame.im(kde_hotelsSG_bw.km)
spplot(gridded_kde_hotelsSG_bw.km)
```

Analysis: The above density map shows a clearer visualization of the density of hotels using grid. We can see that south-east area near the central have higher density of about 50 - 120 units per square kilometer as seen by the lighter blue and pink grid on the map. There are some hotels scattered near east area as well as shown by the individual blue grid.

##### 5.1.1.2.4 Plot raster on osm

1. The following code chunk first compute kernel density using density function of spatstat package with sigma set as bw.diggle and kernel set as gaussian. 

2. Note that we will be using ppp in m. 

3. Convert KDE output into grid object using as.SpatialGridDataFrame.im function of maptools

4. Convert grid object into raster using raster function of raster package

5. Assign CRS to raster layer 

6. Plot the raster on OpenstreetMap basemap in interactive mode

7. tmap_mode is set to view to plot interative map

8. tm_shape is the raster layer

9. tm_raster with setting of alpha = 0.7 makes the raster layer slightly transparent so that the basemap can be seen, palette set to Purples

10. tm_basemap is set to OpenStreetMap

11. tmap_mode change back to plot


```{r}
kde_hotelsSG_bw <- density(hotelsSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

gridded_kde_hotelsSG_bw <- as.SpatialGridDataFrame.im(kde_hotelsSG_bw)

kde_hotelsSG_bw_raster <- raster(gridded_kde_hotelsSG_bw)
projection(kde_hotelsSG_bw_raster) <- CRS("+init=EPSG:3414")

tmap_mode("view")
tm_shape(kde_hotelsSG_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7) +
  tm_basemap("OpenStreetMap")

tmap_mode("plot")
```

Analysis: From the raster map, we can see that areas such as Gelang and Clarke Quay have highest density of hotels with about 0.00015 to 0.00020 units per square meter. Areas like Rochor and Chinatown have high density of about 0.00005 to 0.00010 units per square meter.

#### 5.1.1.3 MRTLRT

##### 5.1.1.3.1 Rescale KDE values

The following code chunk rescale the KDE value of mrtlrtSG_ppp using rescale function of spatstat from meter to kilometer.

```{r}
mrtlrtSG_ppp.km <- rescale(mrtlrtSG_ppp, 1000, "km")
```

##### 5.1.1.3.2 KDE Map and Point Map in km

The following code chunk is similar to Airbnb0619's code chunk (5.1.1.1.4).

```{r}
kde_mrtlrtSG_bw.km <- density(mrtlrtSG_ppp.km,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

par(mfrow=c(1,2))
plot(kde_mrtlrtSG_bw.km, main = "KDE Map")
plot(mrtlrtSG_ppp.km, main="Point Map")
```

Analysis: From the kde map above, we can see that the mrt and lrt are available at almost every region. Area with higher density of MRT are North-East, North-West and Central South region with about 2 to 3 units per square kilometer, as shown by the pink orange patch on the kde map. The black patches on the point map also concentrates in these three region. 

##### 5.1.1.3.3 Convert KDE output into grid object in km

The following code chunk converts KDE output into grid object using as.SpatialGridDataFrame.im function of maptools, and plot the grid object using spplot function of raster package.

```{r}
gridded_kde_mrtlrtSG_bw.km <- as.SpatialGridDataFrame.im(kde_mrtlrtSG_bw.km)
spplot(gridded_kde_mrtlrtSG_bw.km)
```

Analysis: The above density map shows a clearer visualization of the density of Mrt and Lrt using grid. We can see that the Mrt and Lrt are available almost every region in Singapore as represented by the light blue grid on the map. The north-east, north-west and central south area have higher density of Mrt and Lrt as seen by the pink to yellow grid cluster on the map. There are many regions with 1 units per square meter as shown by blue green. 

##### 5.1.1.3.4 Plot raster on osm

The following code chunk is similar to Hotels (5.1.1.2.4)

```{r}
kde_mrtlrtSG_bw <- density(mrtlrtSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

gridded_kde_mrtlrtSG_bw <- as.SpatialGridDataFrame.im(kde_mrtlrtSG_bw)

kde_mrtlrtSG_bw_raster <- raster(gridded_kde_mrtlrtSG_bw)
projection(kde_mrtlrtSG_bw_raster) <- CRS("+init=EPSG:3414")

tmap_mode("view")
tm_shape(kde_mrtlrtSG_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7) +
  tm_basemap("OpenStreetMap")

tmap_mode("plot")
```

Analysis: From the raster map above, we can confirm that North-east, North-west and Central south area have higher density of Mrt and Lrt of about 0.000002 to 0.000003 units per square meter, as shown by the purple grid on the map.

#### 5.1.1.4 Tourist Attractions

##### 5.1.1.4.1 Rescale KDE values

The following code chunk rescale the KDE value of mrtlrtSG_ppp using rescale function of spatstat from meter to kilometer.

```{r}
tourismSG_ppp.km <- rescale(tourismSG_ppp, 1000, "km")
```

##### 5.1.1.4.2 KDE Map and Point Map in km

The following code chunk is similar to Airbnb0619's code chunk (5.1.1.1.4).

```{r}
kde_tourismSG_bw.km <- density(tourismSG_ppp.km,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

par(mfrow=c(1,2))
plot(kde_tourismSG_bw.km, main = "KDE Map")
plot(tourismSG_ppp, main="Point Map")
```

Analysis: From the kde map above, we can see that the south-east region near the central area have higher density of tourist attraction as shown on the pink-yellow spots with about 10 - 20 units per square kilometer. In the point map, the black patches also concentrates at the south-east region near central, with some individual attraction in north, west and east as shown by the individual point.

##### 5.1.1.4.3 Convert KDE output into grid object in km

The following code chunk converts KDE output into grid object using as.SpatialGridDataFrame.im function of maptools, and plot the grid object using spplot function of raster package.

```{r}
gridded_kde_tourismSG_bw.km <- as.SpatialGridDataFrame.im(kde_tourismSG_bw.km)
spplot(gridded_kde_tourismSG_bw.km)
```

Analysis: The above density map shows a clearer visualization of the density of tourist attraction in Singapore using grid. We can see that there are a few attractions in the north, west and east as seen by the light blue grid on the map. The south central area have high density of tourist attractions as seen by the pink yellow grid on the map with about 10 to 20 units per square meter.

##### 5.1.1.4.4 Plot raster on osm

The following code chunk is similar to Hotels (5.1.1.2.4)

```{r}
kde_tourismSG_bw <- density(tourismSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

gridded_kde_tourismSG_bw <- as.SpatialGridDataFrame.im(kde_tourismSG_bw)

kde_tourismSG_bw_raster <- raster(gridded_kde_tourismSG_bw)
projection(kde_tourismSG_bw_raster) <- CRS("+init=EPSG:3414")

tmap_mode("view")
tm_shape(kde_tourismSG_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7) +
  tm_basemap("OpenStreetMap")

tmap_mode("plot")
```

Analysis: From the raster map above, we can confirm the the south-east area near central region have highest density of tourist attraction with about 0.000020 to 0.000025 units per square meter as shown by the dark purple grid on the map.

#### 5.1.1.5 Comparison between Airbnb0619, Hotels, MRTLRT and Tourist Attractions

##### 5.1.1.5.1 KDE Map Comparison

The following code chunk plots the KDE map of Airbnb 2019, Hotel, MRTLRT and Tourist Attractions side by side using par functions of graphics package

```{r fig.width=8, fig.height=8}
par(mfrow=c(2,2))
plot(kde_airbnb0619SG_bw.km, main = "Airbnb 2019")
plot(kde_hotelsSG_bw.km, main = "Hotel")
plot(kde_mrtlrtSG_bw.km, main = "Mrt")
plot(kde_tourismSG_bw.km, main = "Tourist Attraction")
```

From the above, we can see that the common area with high density (in red and yellow) of Airbnb, hotel, mrt and tourist attraction are concentrated around the south east area near the central region.

#### 5.1.1.6 Comparing Spatial Point Patterns using KDE

From the Airbnb kde map above, we noticed that areas such as Kallang, Geylang, Chinatown and Anson have a higher density as shown by the darker purple grid. Hence, we will look into these areas. 

Subzone Kallang = Planning Area Kallang

Subzone Geylang = Planning Area Geylang

Subzone Chinatown = Planning Area Outram

Subzone Anson = Planning Area Downtown Core

##### 5.1.1.6.1 Extract Study Area

The following code chunk extracts the target areas (Kallang, Geylang, Outram, Downtown Core).

```{r}
kl = mpsz[mpsz@data$PLN_AREA_N == "KALLANG",]
gl = mpsz[mpsz@data$PLN_AREA_N == "GEYLANG",]
ot = mpsz[mpsz@data$PLN_AREA_N == "OUTRAM",]
dc = mpsz[mpsz@data$PLN_AREA_N == "DOWNTOWN CORE",]
```

##### 5.1.1.6.2 Plot target areas

The following code chunk plots the target areas side by side in 2x2 using par function of graphics package and plot functions of base R package. 

```{r}
par(mfrow=c(2,2))
plot(kl, main = "KALLANG")
plot(gl, main = "GEYLANG")
plot(ot, main = "OUTRAM")
plot(dc, main = "DOWNTOWN CORE")
```

##### 5.1.1.6.3 Convert Spatial Polygons Data Fraeme into generic SP format

The following code chunk converts the four SpatialPolygonsDataFrame layers into generic spatialpolygons layers.

```{r}
kl_sp = as(kl, "SpatialPolygons")
gl_sp = as(gl, "SpatialPolygons")
ot_sp = as(ot, "SpatialPolygons")
dc_sp = as(dc, "SpatialPolygons")
```

##### 5.1.1.6.4 Create owin object for each target area

The following code chunk convert the SpatialPolygons objects into owin objects required by spatstat.

```{r}
kl_owin = as(kl_sp, "owin")
gl_owin = as(gl_sp, "owin")
ot_owin = as(ot_sp, "owin")
dc_owin = as(dc_sp, "owin")
```

##### 5.1.1.6.5 Combine airnbnb0619, hotels, mrt, tourist attractions points with owin of each target area

The following code chunk extracts airnbnb0619, hotels, mrt and tourist attractions within each specific region.

```{r}
airbnb0619_kl_ppp = airbnb0619_ppp_jit[kl_owin]
airbnb0619_gl_ppp = airbnb0619_ppp_jit[gl_owin]
airbnb0619_ot_ppp = airbnb0619_ppp_jit[ot_owin]
airbnb0619_dc_ppp = airbnb0619_ppp_jit[dc_owin]

hotels_kl_ppp = hotels_ppp_jit[kl_owin]
hotels_gl_ppp = hotels_ppp_jit[gl_owin]
hotels_ot_ppp = hotels_ppp_jit[ot_owin]
hotels_dc_ppp = hotels_ppp_jit[dc_owin]

mrtlrt_kl_ppp = mrtlrt_ppp[kl_owin]
mrtlrt_gl_ppp = mrtlrt_ppp[gl_owin]
mrtlrt_ot_ppp = mrtlrt_ppp[ot_owin]
mrtlrt_dc_ppp = mrtlrt_ppp[dc_owin]

tourism_kl_ppp = tourism_ppp_jit[kl_owin]
tourism_gl_ppp = tourism_ppp_jit[gl_owin]
tourism_ot_ppp = tourism_ppp_jit[ot_owin]
tourism_dc_ppp = tourism_ppp_jit[dc_owin]
```

##### 5.1.1.6.6 Rescale from m to km

The following code chunk transform the unit from m to km using rescale function.

```{r}
airbnb0619_kl_ppp.km = rescale(airbnb0619_kl_ppp, 1000, "km")
airbnb0619_gl_ppp.km = rescale(airbnb0619_gl_ppp, 1000, "km")
airbnb0619_ot_ppp.km = rescale(airbnb0619_ot_ppp, 1000, "km")
airbnb0619_dc_ppp.km = rescale(airbnb0619_dc_ppp, 1000, "km")

hotels_kl_ppp.km = rescale(hotels_kl_ppp, 1000, "km")
hotels_gl_ppp.km = rescale(hotels_gl_ppp, 1000, "km")
hotels_ot_ppp.km = rescale(hotels_ot_ppp, 1000, "km")
hotels_dc_ppp.km = rescale(hotels_dc_ppp, 1000, "km")

mrtlrt_kl_ppp.km = rescale(mrtlrt_kl_ppp, 1000, "km")
mrtlrt_gl_ppp.km = rescale(mrtlrt_gl_ppp, 1000, "km")
mrtlrt_ot_ppp.km = rescale(mrtlrt_ot_ppp, 1000, "km")
mrtlrt_dc_ppp.km = rescale(mrtlrt_dc_ppp, 1000, "km")

tourism_kl_ppp.km = rescale(tourism_kl_ppp, 1000, "km")
tourism_gl_ppp.km = rescale(tourism_gl_ppp, 1000, "km")
tourism_ot_ppp.km = rescale(tourism_ot_ppp, 1000, "km")
tourism_dc_ppp.km = rescale(tourism_dc_ppp, 1000, "km")
```

##### 5.1.1.6.7 Airbnb comparison by area in km

The following code chunk plots airbnb within each area using plot and density functions with sigma set to bw.diggle and kernel set to gaussian.

```{r fig.width=8, fig.height=8}
par(mfrow=c(2,2))
plot(density(airbnb0619_kl_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Kallang")
plot(density(airbnb0619_gl_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Geylang")
plot(density(airbnb0619_ot_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Outram")
plot(density(airbnb0619_dc_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Downtown Core")
```

Analysis: From the comparison, we noticed that the scale range for each region are different. For example, Kallang have a smaller scale range from 0 - 2000 units per square kilometer as compared to Geylang with a larger scale range of 0 - 5000 units per square kilometer. In Kallang, Airbnb are denser around the North-west area with highest density of around 1500 to 2500 units per square kilometer. In Geylang, Airbnb are denser at South area with highest density of 2000 to 5000 units per square kilometer. In Outram, the Central area are denser with highest density of Airbnb of around 2000 to 4000 units per square kilometer. In Downtown Core, the South-west region have highest density of Airbnb at about 2000 to 4000 units per square kilometer.


##### 5.1.1.6.8 Airbnb raster within area

###### 5.1.1.6.8.1 Kallang

1. The following code chunk first get bounding box of the area using getbb function of osmdata package. The function takes in place_name of the area and output format of sf_polygon

2. set bb projecion to 3414 using st_set_crs function of sf package

3. read open street map data using read_osm function of tmaptools package

4. Compute kernel density using density function of spatstat package with sigma set as bw.diggle and kernel set as gaussian. 

2. Note that we will be using ppp in m. 

3. Convert KDE output into grid object using as.SpatialGridDataFrame.im function of maptools

4. Convert grid object into raster using raster function of raster package

5. Assign CRS to raster layer 

6. Plot the raster on static OpenstreetMap basemap 

7. first tm_shape is the static osm obtained earlier with tm_rgb of tmao

8. second tm_shape is the raster layer

9. tm_raster with setting of alpha = 0.7 makes the raster layer slightly transparent so that the basemap can be seen, palette set to Purples, layout of the legend at the bottom right area.

```{r}
kl_bb <- getbb("kallang singapore", format_out = "sf_polygon")
st_set_crs(kl_bb, 3414)
kl_bb_osm <- read_osm(kl_bb, type = "osm")

kde_airbnb0619_kl_bw <- density(airbnb0619_kl_ppp, 
                              sigma=bw.diggle, 
                               edge=TRUE, 
                               kernel="gaussian")

gridded_kde_airbnb0619_kl_bw <- as.SpatialGridDataFrame.im(kde_airbnb0619_kl_bw)
kde_airbnb0619_kl_bw_raster <- raster(gridded_kde_airbnb0619_kl_bw)
projection(kde_airbnb0619_kl_bw_raster) <- CRS("+init=EPSG:3414")

tm_shape(kl_bb_osm) + 
  tm_rgb() +
  tm_shape(kde_airbnb0619_kl_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), legend.frame = TRUE)
```



###### 5.1.1.6.8.2 Geylang

The following code chunk is similar to 5.1.1.6.8.1

```{r}
gl_bb <- getbb("geylang singapore", format_out = "sf_polygon")
st_set_crs(gl_bb, 3414)
gl_bb_osm <- read_osm(gl_bb, type = "osm")

kde_airbnb0619_gl_bw <- density(airbnb0619_gl_ppp, 
                              sigma=bw.diggle, 
                               edge=TRUE, 
                               kernel="gaussian")

gridded_kde_airbnb0619_gl_bw <- as.SpatialGridDataFrame.im(kde_airbnb0619_gl_bw)
kde_airbnb0619_gl_bw_raster <- raster(gridded_kde_airbnb0619_gl_bw)
projection(kde_airbnb0619_gl_bw_raster) <- CRS("+init=EPSG:3414")

tm_shape(gl_bb_osm) + 
  tm_rgb() +
  tm_shape(kde_airbnb0619_gl_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), legend.frame = TRUE)
```

###### 5.1.1.6.8.3 Outram

The following code chunk is similar to 5.1.1.6.8.1

```{r}
ot_bb <- getbb("outram singapore", format_out = "sf_polygon")
st_set_crs(ot_bb, 3414)
ot_bb_osm <- read_osm(ot_bb, type = "osm")

kde_airbnb0619_ot_bw <- density(airbnb0619_ot_ppp, 
                              sigma=bw.diggle, 
                               edge=TRUE, 
                               kernel="gaussian")

gridded_kde_airbnb0619_ot_bw <- as.SpatialGridDataFrame.im(kde_airbnb0619_ot_bw)
kde_airbnb0619_ot_bw_raster <- raster(gridded_kde_airbnb0619_ot_bw)
projection(kde_airbnb0619_ot_bw_raster) <- CRS("+init=EPSG:3414")

tm_shape(ot_bb_osm) + 
  tm_rgb() +
  tm_shape(kde_airbnb0619_ot_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), legend.frame = TRUE)
```

###### 5.1.1.6.8.4 Downtown Core

The following code chunk is similar to 5.1.1.6.8.1

```{r}
dc_bb <- getbb("downtown core singapore", format_out = "sf_polygon")
st_set_crs(dc_bb, 3414)
dc_bb_osm <- read_osm(dc_bb, type = "osm")

kde_airbnb0619_dc_bw <- density(airbnb0619_dc_ppp, 
                              sigma=bw.diggle, 
                               edge=TRUE, 
                               kernel="gaussian")

gridded_kde_airbnb0619_dc_bw <- as.SpatialGridDataFrame.im(kde_airbnb0619_dc_bw)
kde_airbnb0619_dc_bw_raster <- raster(gridded_kde_airbnb0619_dc_bw)
projection(kde_airbnb0619_dc_bw_raster) <- CRS("+init=EPSG:3414")

tm_shape(dc_bb_osm) + 
  tm_rgb() +
  tm_shape(kde_airbnb0619_dc_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), legend.frame = TRUE)
```

Analysis: From the four static raster map above, we can clearly see the exact location with the highest density of Airbnb in each area.

##### 5.1.1.6.9 Airbnb, Hotels, Mrt, Tourist Attraction in each area in km

###### 5.1.1.6.9.1 Kallang

The following code chunk plots airbnb, hotel, mrt and tourist attraction in Kallang.

```{r fig.width=8, fig.height=8}
par(mfrow=c(2,2))
plot(airbnb0619_kl_ppp.km, main = "Airbnb")
plot(hotels_kl_ppp.km, main = "Hotel")
plot(mrtlrt_kl_ppp.km, main = "Mrt")
plot(tourism_kl_ppp.km, main = "Tourist Attraction")
```

Analysis: Even though there are already some hotels available and only one tourist attraction, there are still many Airbnb in Kallang. There are eight MRT stations, which may be the reason why there are many Airbnb located in this area.

###### 5.1.1.6.9.2 Geylang

The following code chunk plots airbnb, hotel, mrt and tourist attraction in Geylang.

```{r fig.width=8, fig.height=8}
par(mfrow=c(2,2))
plot(airbnb0619_gl_ppp.km, main = "Airbnb")
plot(hotels_gl_ppp.km, main = "Hotel")
plot(mrtlrt_gl_ppp.km, main = "Mrt")
plot(tourism_gl_ppp.km, main = "Tourist Attraction")
```

Analysis: Similar to Kallang, even though there are already quite a number of hotels in Geylang and no tourist attraction, there are still many Airbnb. There are a number of Mrt stations, which may be the reason why there are many Airbnb located in this area.

###### 5.1.1.6.9.3 Outram

The following code chunk plots airbnb, hotel, mrt and tourist attraction in Outram.

```{r fig.width=8, fig.height=8}
par(mfrow=c(2,2))
plot(airbnb0619_ot_ppp.km, main = "Airbnb")
plot(hotels_ot_ppp.km, main = "Hotel")
plot(mrtlrt_ot_ppp.km, main = "Mrt")
plot(tourism_ot_ppp.km, main = "Tourist Attraction")
```

Analysis: Even though there are already a few hotels in Outram, there are still many Airbnb. The accessibility to the few MRT and  tourist attractions can be the reason why Outram have many Airbnb. In addition, we can see that the area with most Airbnbs (black patch) area where the tourist attractions are located.

###### 5.1.1.6.9.4 Downtown Core

The following code chunk plots airbnb, hotel, mrt and tourist attraction in Downtown Core.

```{r fig.width=8, fig.height=8}
par(mfrow=c(2,2))
plot(airbnb0619_dc_ppp.km, main = "Airbnb")
plot(hotels_dc_ppp.km, main = "Hotel")
plot(mrtlrt_dc_ppp.km, main = "Mrt")
plot(tourism_dc_ppp.km, main = "Tourist Attraction")
```

Analysis: In Downtown core, there are still many airbnb despite many hotels already available. The accessibility to many MRTs and multiple tourist attractions may be the reason that many airbnb are located in this area.

Overall, we can conclude that there are no direct relationship between airbnb and hotel as we see that regardless of the number of hotel available in a region, the number of airbnb remained high. Tourist attractions also do not have direct relationship with Airbnb because areas like Kallang and Geylang still have many Airbnb even though they only have one tourist attraction in the area. The accessibility of MRT is one of the possible factor that affects the number of Airbnb in the area. 

## 5.2 Second-order Spatial Point Patterns Analysis

### 5.2.1 Nearest Neighbour Analysis

We will perform Nearest Neighbour Analysis to determine if the distributions of Airbnb in each area are random distributed or not.

#### 5.2.1.1 Hypothesis

We will perform the Clark-Evans test of aggregation for a spatial point pattern using clarkevans.test() of statspat.

Test Hypothesis:

H0 = The distribution of airbnbs are randomly distributed.

H1 = The distribution of airbnbs are not randomly distributed.

The 95% confident interval will be used.

#### 5.2.1.2 Testing and Analysis

##### 5.2.1.2.1 Testing spatial point patterns using Clark and Evans Test

1. The following code chunk performs Clark-Evans test using clarkevans.test() of statspat.
2. The spatial point pattern object is airbnb0619SG_ppp, Singapore airbnb listings in Singapore ppp object.
3. Correction is set to none
4. The clipping region is set to sg_owin
5. The type of alternative for the hypothesis is clustered.
6. The number of simulations is set to 99.

```{r}
clarkevans.test(airbnb0619SG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

Analysis: R = 0.36 is less than 1, which means the distribution of airbnb in Singapore are likely clustered. The p-value of 0.01 is smaller than 0.05. Hence, we reject the null hypothesis that the airbnb point patterns in Singapore are randomly distributed.

##### 5.2.1.2.2 Clark and Evans Test: Kallang

1. The following code chunk performs Clark-Evans test of aggregation for airbnb in Kallang using clarkevans.test() of spatstat
2. The clipping region is set to NULL
3. The type of alternative for the hypothesis is two.sided
4. The number of simulations is set to 999

```{r}
clarkevans.test(airbnb0619_kl_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

Analysis: The p-value of 0.002 is smaller than 0.05. Hence, we reject the null hypothesis that the airbnb point patterns in Kallang are randomly distributed.

##### 5.2.1.2.3 Clark and Evans Test: Geylang

1. The following code chunk performs Clark-Evans test of aggregation for airbnb in Geylang using clarkevans.test() of spatstat
2. The clipping region is set to NULL
3. The type of alternative for the hypothesis is two.sided
4. The number of simulations is set to 999

```{r}
clarkevans.test(airbnb0619_gl_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

Analysis: The p-value of 0.002 is smaller than 0.05. Hence, we reject the null hypothesis that the airbnb point patterns in Geylang are randomly distributed.

##### 5.2.1.2.4 Clark and Evans Test: Outram

1. The following code chunk performs Clark-Evans test of aggregation for airbnb in Outram using clarkevans.test() of spatstat
2. The clipping region is set to NULL
3. The type of alternative for the hypothesis is two.sided
4. The number of simulations is set to 999

```{r}
clarkevans.test(airbnb0619_ot_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

Analysis: The p-value of 0.002 is smaller than 0.05. Hence, we reject the null hypothesis that the airbnb point patterns in Outram are randomly distributed.

##### 5.2.1.2.5 Clark and Evans Test: Downtown Core

1. The following code chunk performs Clark-Evans test of aggregation for airbnb in Downtown Core using clarkevans.test() of spatstat
2. The clipping region is set to NULL
3. The type of alternative for the hypothesis is two.sided
4. The number of simulations is set to 999

```{r}
clarkevans.test(airbnb0619_dc_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

Analysis: The p-value of 0.002 is smaller than 0.05. Hence, we reject the null hypothesis that the airbnb point patterns in Downtown Core are randomly distributed.

Overall, we can conclude that airbnb in the four areas are not randomly distributed. For further analysis, we will narrow down to two areas, Downtown Core and Outram, with R value above 0.5 and 0.7 respectively. When R is nearer to 1, the distribution are likely to be random. Hence, we are interested to further analyse the distribution of airbnb within these two region.

### 5.2.2 G-FUNCTION

The G function measures the distribution of the distances from an arbitrary event to its nearest event. 

#### 5.2.2.1 Downtown Core

##### 5.2.2.1.1 Compute G-Function Estimation

The following code chunk computes G-function using Gest() of spatat package.

```{r}
G_DC = Gest(airbnb0619_dc_ppp, correction = "border")
plot(G_DC, xlim=c(0,150))
```

Analysis: From the G function plot above, we can see that G(r) increase sharply at short distance at the start and eventually increase slowly after around 25. This shows that Airbnb in Downtown Core are likely to be clustered.

##### 5.2.2.1.2 Complete Spatial Randomness Test

Hypothesis:

H0 = The distribution of airbnb in Downtown Core are randomly distributed.

H1= The distribution of airbnb in Downtown Core are not randomly distributed.

The null hypothesis will be rejected is p-value is smaller than alpha value of 0.001 (at 99.9% confidence interval)

The following code chunk performs monta carlo simulation test using envelope() and Gest of spatstat package.

```{r}
G_DC.csr <- envelope(airbnb0619_dc_ppp, Gest, nsim = 999)
```

The following code chunk plots the csr

```{r}
plot(G_DC.csr)
```

Analysis: The observed G(r) is above the envelopes which means that Airbnb in Downtown Core area are clustered. Hence, we reject the null hypothesis that Airbnb in Downtown Core are randomly distributed at 99.9% confident interval.

#### 5.2.2.2 Outram

##### 5.2.2.2.1 Compute G-Function Estimation

The following code chunk computes G-function using Gest() of spatat package.

```{r}
G_OT = Gest(airbnb0619_ot_ppp, correction = "border")
plot(G_OT, xlim=c(0,100))
```

Analysis: From the G function plot above, we can see that G(r) increase sharply at short distance at the start and eventually increase slowly after around 25. This shows that Airbnb in Outram are likely to be clustered.

##### 5.2.2.2.2 Complete Spatial Randomness Test

Hypothesis:

H0 = The distribution of airbnb in Outram are randomly distributed.

H1= The distribution of airbnb in Outram are not randomly distributed.

The null hypothesis will be rejected is p-value is smaller than alpha value of 0.001.

The following code chunk performs monta carlo simulation test using envelope() and Gest of spatstat package.

```{r}
G_OT.csr <- envelope(airbnb0619_ot_ppp, Gest, nsim = 999)
```

The following code chunk plots the csr

```{r}
plot(G_OT.csr)
```

Analysis: The observed G(r) is above the envelopes which means that Airbnb in Outram area are clustered. Hence, we reject the null hypothesis that Airbnb in Outram are randomly distributed at 99.9% confident interval.

### 5.2.3 F-FUNCTION

The F function estimates the empty space function F(r) or its hazard rate h(r) from a point pattern in a window of arbitrary shape.

#### 5.2.3.1 Downtown Core

##### 5.2.3.1.1 Compute F-Function Estimation

The following code chunk compute F-function using Fest() of spatat package.

```{r}
F_DC = Fest(airbnb0619_dc_ppp)
plot(F_DC)
```

Analysis: From the F plot above, the F(r) rises slowly from the start for quite a distance. This means Airbnb in Downtown Core are likely to be clustered.

##### 5.2.3.1.2 Complete Spatial Randomness Test

Hypothesis:

H0 = The distribution of airbnb in Downtown Core are randomly distributed.

H1= The distribution of airbnb in Downtown Core are not randomly distributed.

The null hypothesis will be rejected is p-value is smaller than alpha value of 0.001.

The following code chunk performs monta carlo simulation test using envelope() and Fest of spatstat package.

```{r}
F_DC.csr <- envelope(airbnb0619_dc_ppp, Fest, nsim = 999)
```

The following code chunk plots the csr

```{r}
plot(F_DC.csr)
```
Analysis: The observed F(r) is below the envelopes, which means that Airbnb in Downtown Core are in clustered pattern. Hence, we reject the null hypothesis that Airbnb in Downtown Core are randomly distributed at 99.9% confident interval.

#### 5.2.3.2 Outram

##### 5.2.3.2.1 Compute F-Function Estimation

The following code chunk compute F-function using Fest() of spatat package.

```{r}
F_OT = Fest(airbnb0619_ot_ppp)
plot(F_OT)
```

Analysis: From the F plot above, the F(r) rises slowly from the start for quite a distance. This means Airbnb in Outram are likely to be clustered.

##### 5.2.3.2.2 Complete Spatial Randomness Test

Hypothesis:

H0 = The distribution of airbnb in Outram are randomly distributed.

H1= The distribution of airbnb in Outram are not randomly distributed.

The null hypothesis will be rejected is p-value is smaller than alpha value of 0.001.

The following code chunk performs monta carlo simulation test using envelope() and Fest of spatstat package.

```{r}
F_OT.csr <- envelope(airbnb0619_ot_ppp, Fest, nsim = 999)
```

The following code chunk plots the csr

```{r}
plot(F_OT.csr)
```

Analysis: The observed F(r) is below the envelopes, which means that Airbnb in Outram are in clustered pattern. Hence, we reject the null hypothesis that Airbnb in Outram are randomly distributed at 99.9% confident interval.

### 5.2.4 L-FUNCTION

L function is a transformation of Ripley's K function. K function provides estimation based on all the distances between events in a study area.

#### 5.2.4.1 Downtown Core

##### 5.2.4.1.1 Compute L-Function Estimation

The following code chunk compute L-function using Lest() of spatat package.

```{r}
L_DC = Lest(airbnb0619_dc_ppp, correction = "Ripley")
plot(L_DC, . -r ~ r, ylab= "L(r)", xlab = "r")
```

Analysis: The above L function plots shows that L(r) is above 0, which means clustering. This means Airbnb in Downtown Core are likely to be clustered.

##### 5.2.4.1.2 Complete Spatial Randomness Test

Hypothesis:

H0 = The distribution of airbnb in Downtown Core are randomly distributed.

H1= The distribution of airbnb in Downtown Core are not randomly distributed.

The null hypothesis will be rejected is p-value is smaller than alpha value of 0.001.

The following code chunk performs the test using envelope() and Lest of spatstat package.

```{r}
L_DC.csr <- envelope(airbnb0619_dc_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

The following code chunk plots the csr

```{r}
plot(L_DC.csr, . - r ~ r, xlab="r", ylab="L(r)")
```

Analysis: The above L function plots shows that the observed L(r) is greater than L(theo) and envelops, which means clustering. This means Airbnb in Downtown Core clustered. Hence, we reject the null hypothesis that Airbnb in Downtown Core are randomly distributed at 99.9% confident interval.

#### 5.2.4.2 Outram

##### 5.2.4.2.1 Compute L-Function Estimation

The following code chunk compute K-function using Lest() of spatat package.

```{r}
L_OT = Lest(airbnb0619_ot_ppp, correction = "Ripley")
plot(L_OT, . -r ~ r, ylab= "L(r)", xlab = "r")
```

Analysis: The above L function plots shows that L(r) is above 0, which means clustering. This means Airbnb in Outram are likely to be clustered.

##### 5.2.4.2.2 Complete Spatial Randomness Test

Hypothesis:

H0 = The distribution of airbnb in Outram are randomly distributed.

H1= The distribution of airbnb in Outram are not randomly distributed.

The null hypothesis will be rejected is p-value is smaller than alpha value of 0.001.

The following code chunk performs the test using envelope() and Lest of spatstat package.

```{r}
L_OT.csr <- envelope(airbnb0619_ot_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

The following code chunk plots the csr

```{r}
plot(L_OT.csr, . - r ~ r, xlab="r", ylab="L(r)")
```

Analysis: The above L function plots shows that the observed L(r) is greater than L(theo) and envelops, which means clustering. This means Airbnb in Outram clustered. Hence, we reject the null hypothesis that Airbnb in Outram are randomly distributed at 99.9% confident interval.

# 6 Section B: Impact of COVID-19

## 6.1 Exploratory Spatial Data Analysis

### 6.1.1 Kernel density maps

#### 6.1.1.1 Airbnb0721 listings

##### 6.1.1.2.1 Rescale KDE values

The following code chunk rescale the KDE value of airbnb0721SG_ppp using rescale function of spatstat from meter to kilometer.

```{r}
airbnb0721SG_ppp.km <- rescale(airbnb0721SG_ppp, 1000, "km")
```

##### 6.1.1.2.2 KDE Map in km

The following code chunk is similar to Airbnb0619's code chunk (5.1.1.1.4).

```{r}
kde_airbnb0721SG_bw.km <- density(airbnb0721SG_ppp.km,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

plot(kde_airbnb0721SG_bw.km, main = "KDE Map")
```

Analysis: From the kde map above, we can see that the south-east region near the central area have higher density of Airbnb with about 200 to 800 units per square kilometer, as shown by the purple, pink and orange spots on kde map.

##### 6.1.1.2.3 Convert KDE output into grid object in km

The following code chunk converts KDE output into grid object using as.SpatialGridDataFrame.im function of maptools, and plot the grid object using spplot function of raster package.

```{r}
gridded_kde_airbnb0721SG_bw.km <- as.SpatialGridDataFrame.im(kde_airbnb0721SG_bw.km)
spplot(gridded_kde_airbnb0721SG_bw.km)
```

Analysis: The above density map shows a clearer visualization of the density of Airbnb in 2021 using grid. We can see that the Airbnb are scattered all around as seen by the lighter blue grid on the map. The south-east area near the central have higher density with around 200 - 800 units per square kilometer, represented by the brighter blue and pink grid on the map.

##### 6.1.1.2.4 Convert into raster

1. The following code chunk first compute kernel density using density function of spatstat package with sigma set as bw.diggle and kernel set as gaussian. 

2. Note that we will be using ppp in m. 

3. Convert KDE output into grid object using as.SpatialGridDataFrame.im function of maptools

4. Convert grid object into raster using raster function of raster package

5. Assign CRS to raster layer

```{r}
kde_airbnb0721SG_bw <- density(airbnb0721SG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

gridded_kde_airbnb0721SG_bw <- as.SpatialGridDataFrame.im(kde_airbnb0721SG_bw)

kde_airbnb0721SG_bw_raster <- raster(gridded_kde_airbnb0721SG_bw)
projection(kde_airbnb0721SG_bw_raster) <- CRS("+init=EPSG:3414")
```

#### 6.1.1.2 Comparison between Airbnb0619 and Airbnb0721

The following code chunk plots kde map of Airbnb0619 and Airbnb0721 side by side.

```{r}
par(mfrow=c(1,2))
plot(kde_airbnb0619SG_bw.km, main = "Airbnb 2019")
plot(kde_airbnb0721SG_bw.km, main = "Airbnb 2021")
```

From the KDE map, the south-east region still have higher density in 2021. However, we noticed that the density of Airbnb have reduced as seen from the scale. It reduced from range 0-1500 units per square kilometer in 2019 to range 0-1000 units per square kilomete in 2021. We can conclude that Covid-19 did impact the Airbnb listing in Singapore from 2019 to 2021.

#### 6.1.1.3 Comparison between Airbnb0619 and Airbnb0721 by Room Type

##### 6.1.1.3.1 Data Wrangling

###### 6.1.1.3.1.1 Determine the unique room type

The following code checks the unique room type using unique features of base R

```{r}
unique(airbnb0619_sf$room_type)
```

We have determined that the unique room types are Private room, Entire home/apt and Shared room for Airbnb 2019.

```{r}
unique(airbnb0721_sf$room_type)
```

We have determined that the unique room types are Private room, Entire home/apt, Shared room and Hotel room for Airbnb 2021.

###### 6.1.1.3.1.2 Filter each room type from SpatialPointsDataFrame

The following code chunk filters each room type for both year.

```{r}
airbnb0619_pte = airbnb0619[airbnb0619@data$room_type == "Private room",]
airbnb0619_ent = airbnb0619[airbnb0619@data$room_type == "Entire home/apt",]
airbnb0619_sh = airbnb0619[airbnb0619@data$room_type == "Shared room",]
airbnb0721_pte = airbnb0721[airbnb0721@data$room_type == "Private room",]
airbnb0721_ent = airbnb0721[airbnb0721@data$room_type == "Entire home/apt",]
airbnb0721_sh = airbnb0721[airbnb0721@data$room_type == "Shared room",]
airbnb0721_ht = airbnb0721[airbnb0721@data$room_type == "Hotel room",]
```

```{r}
airbnb0721_sh
```

Notice that the data are in SpatialPointsDataFrame format

###### 6.1.1.3.1.3 Converting the Spatial* class into generic sp format

Next, we will convert Spatial* classes into Spatial object so that we can convert it into ppp object.

The following code chunk converts Spatial* classes into generic sp format using as function which sets the classes to their respective sp format. 

```{r}
airbnb0619_pte_sp <- as(airbnb0619_pte, "SpatialPoints")
airbnb0619_ent_sp <- as(airbnb0619_ent, "SpatialPoints")
airbnb0619_sh_sp <- as(airbnb0619_sh, "SpatialPoints")
airbnb0721_pte_sp <- as(airbnb0721_pte, "SpatialPoints")
airbnb0721_ent_sp <- as(airbnb0721_ent, "SpatialPoints")
airbnb0721_sh_sp <- as(airbnb0721_sh, "SpatialPoints")
airbnb0721_ht_sp <- as(airbnb0721_ht, "SpatialPoints")
```


###### 6.1.1.3.1.4 Converting the generic sp format into spatstat’s ppp format

We will next convert the spatial data into spatstat's ppp format.

The following code chunk converts spatial data into spatstat's ppp format using as function. 

```{r}
airbnb0619_pte_ppp <- as(airbnb0619_pte_sp, "ppp")
airbnb0619_ent_ppp <- as(airbnb0619_ent_sp, "ppp")
airbnb0619_sh_ppp <- as(airbnb0619_sh_sp, "ppp")
airbnb0721_pte_ppp <- as(airbnb0721_pte_sp, "ppp")
airbnb0721_ent_ppp <- as(airbnb0721_ent_sp, "ppp")
airbnb0721_sh_ppp <- as(airbnb0721_sh_sp, "ppp")
airbnb0721_ht_ppp <- as(airbnb0721_ht_sp, "ppp")
```

###### 6.1.1.3.1.5 Check for duplicates in each ppp's objects

The following code chunk use any and duplicated function of base R package to check for duplicates, and sum up the count of duplicated points using sum function of base R package and multiplicity function of spatstat package.

```{r}
any(duplicated(airbnb0619_pte_ppp))
sum(multiplicity(airbnb0619_pte_ppp) > 1)
```

```{r}
any(duplicated(airbnb0619_ent_ppp))
sum(multiplicity(airbnb0619_ent_ppp) > 1)
```

```{r}
any(duplicated(airbnb0619_sh_ppp))
sum(multiplicity(airbnb0619_sh_ppp) > 1)
```

```{r}
any(duplicated(airbnb0721_pte_ppp))
sum(multiplicity(airbnb0721_pte_ppp) > 1)
```

```{r}
any(duplicated(airbnb0721_ent_ppp))
sum(multiplicity(airbnb0721_ent_ppp) > 1)
```

```{r}
any(duplicated(airbnb0721_sh_ppp))
sum(multiplicity(airbnb0721_sh_ppp) > 1)
```

```{r}
any(duplicated(airbnb0721_ht_ppp))
sum(multiplicity(airbnb0721_ht_ppp) > 1)
```

###### 6.1.1.3.1.6 Handling Duplicates

We will use jittering to handle duplicates so that we will not lose useful points. Jittering adds a small perturbation to the duplicated points so that they do not occupy the exact same space.

The following code chunk uses rjitter function of spatstat to jitter the ppp object with duplicates.

```{r}
airbnb0619_ent_ppp_jit <- rjitter(airbnb0619_ent_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

airbnb0619_sh_ppp_jit <- rjitter(airbnb0619_sh_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

airbnb0721_pte_ppp_jit <- rjitter(airbnb0721_pte_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

airbnb0721_ent_ppp_jit <- rjitter(airbnb0721_ent_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

airbnb0721_sh_ppp_jit <- rjitter(airbnb0721_sh_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

airbnb0721_ht_ppp_jit <- rjitter(airbnb0721_ht_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

###### 6.1.1.3.1.7 Check if duplicates still exist

```{r}
any(duplicated(airbnb0619_ent_ppp_jit))
sum(multiplicity(airbnb0619_ent_ppp_jit) > 1)
```

```{r}
any(duplicated(airbnb0619_sh_ppp_jit))
sum(multiplicity(airbnb0619_sh_ppp_jit) > 1)
```

```{r}
any(duplicated(airbnb0721_pte_ppp_jit))
sum(multiplicity(airbnb0721_pte_ppp_jit) > 1)
```

```{r}
any(duplicated(airbnb0721_ent_ppp_jit))
sum(multiplicity(airbnb0721_ent_ppp_jit) > 1)
```

```{r}
any(duplicated(airbnb0721_sh_ppp_jit))
sum(multiplicity(airbnb0721_sh_ppp_jit) > 1)
```

```{r}
any(duplicated(airbnb0721_ht_ppp_jit))
sum(multiplicity(airbnb0721_ht_ppp_jit) > 1)
```

We can confirm that there are no duplicated points after jittering.

###### 6.1.1.3.1.8 Combining point events object and owin object

The following code chunk combines the point objects with the owin object into one ppp object class.

```{r}
airbnb0619SG_pte_ppp = airbnb0619_pte_ppp[sg_owin]
airbnb0619SG_ent_ppp = airbnb0619_ent_ppp_jit[sg_owin]
airbnb0619SG_sh_ppp = airbnb0619_sh_ppp_jit[sg_owin]
airbnb0721SG_pte_ppp = airbnb0721_pte_ppp_jit[sg_owin]
airbnb0721SG_ent_ppp = airbnb0721_ent_ppp_jit[sg_owin]
airbnb0721SG_sh_ppp = airbnb0721_sh_ppp_jit[sg_owin]
airbnb0721SG_ht_ppp = airbnb0721_ht_ppp_jit[sg_owin]
```

###### 6.1.1.3.1.9 KDE

1. The following code chunk computes kernel density using density function of spatstat package.
2. The code first takes in the ppp object variable in km.
3. bw.diggle automatic bandwidth method to detect a tight cluster
4. smoothing kernel is set to default gaussian method

```{r}
kde_airbnb0619SG_pte_bw <- density(airbnb0619SG_pte_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

kde_airbnb0619SG_ent_bw <- density(airbnb0619SG_ent_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

kde_airbnb0619SG_sh_bw <- density(airbnb0619SG_sh_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

kde_airbnb0721SG_pte_bw <- density(airbnb0721SG_pte_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

kde_airbnb0721SG_ent_bw <- density(airbnb0721SG_ent_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

kde_airbnb0721SG_sh_bw <- density(airbnb0721SG_sh_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")

kde_airbnb0721SG_ht_bw <- density(airbnb0721SG_ht_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")
```

###### 6.1.1.3.1.10 Convert KDE output into grid object

The following code chunk converts KDE output into grid object using as.SpatialGridDataFrame.im function of maptools

```{r}
gridded_kde_airbnb0619SG_pte_bw <- as.SpatialGridDataFrame.im(kde_airbnb0619SG_pte_bw)
gridded_kde_airbnb0619SG_ent_bw <- as.SpatialGridDataFrame.im(kde_airbnb0619SG_ent_bw)
gridded_kde_airbnb0619SG_sh_bw <- as.SpatialGridDataFrame.im(kde_airbnb0619SG_sh_bw)
gridded_kde_airbnb0721SG_pte_bw <- as.SpatialGridDataFrame.im(kde_airbnb0721SG_pte_bw)
gridded_kde_airbnb0721SG_ent_bw <- as.SpatialGridDataFrame.im(kde_airbnb0721SG_ent_bw)
gridded_kde_airbnb0721SG_sh_bw <- as.SpatialGridDataFrame.im(kde_airbnb0721SG_sh_bw)
gridded_kde_airbnb0721SG_ht_bw <- as.SpatialGridDataFrame.im(kde_airbnb0721SG_ht_bw)
```

###### 6.1.1.3.1.11 Convert grid object into raster and assign project system

The following code chunk converts grid object into raster using raster function of raster package, and assign CRS projection of 3414 to the raster layer.

```{r}
kde_airbnb0619SG_pte_bw_raster <- raster(gridded_kde_airbnb0619SG_pte_bw)
projection(kde_airbnb0619SG_pte_bw_raster) <- CRS("+init=EPSG:3414")

kde_airbnb0619SG_ent_bw_raster <- raster(gridded_kde_airbnb0619SG_ent_bw)
projection(kde_airbnb0619SG_ent_bw_raster) <- CRS("+init=EPSG:3414")

kde_airbnb0619SG_sh_bw_raster <- raster(gridded_kde_airbnb0619SG_sh_bw)
projection(kde_airbnb0619SG_sh_bw_raster) <- CRS("+init=EPSG:3414")

kde_airbnb0721SG_pte_bw_raster <- raster(gridded_kde_airbnb0721SG_pte_bw)
projection(kde_airbnb0721SG_pte_bw_raster) <- CRS("+init=EPSG:3414")

kde_airbnb0721SG_ent_bw_raster <- raster(gridded_kde_airbnb0721SG_ent_bw)
projection(kde_airbnb0721SG_ent_bw_raster) <- CRS("+init=EPSG:3414")

kde_airbnb0721SG_sh_bw_raster <- raster(gridded_kde_airbnb0721SG_sh_bw)
projection(kde_airbnb0721SG_sh_bw_raster) <- CRS("+init=EPSG:3414")

kde_airbnb0721SG_ht_bw_raster <- raster(gridded_kde_airbnb0721SG_ht_bw)
projection(kde_airbnb0721SG_ht_bw_raster) <- CRS("+init=EPSG:3414")
```

##### 6.1.1.3.2 KDE Map Comparison by Room type and Year

The following code chunks plot KDE map of Airbnb 2019 and 2021 by each room types side by side.

###### 6.1.1.3.2.1 Private Room

1. The following code chunk first set tmap_mode to view to plot interactive map

2. Create two maps

3. Each map is plotted with tm_shape of the raster layer, tm_raster with setting of alpha = 0.7 that makes the raster layer slightly transparent so that the basemap can be seen, palette set to Purples, tm_basemap is set to OpenStreetMap

4. tmap_arrange to arrange the plot next to each other.

5. tmap_mode change back to plot

```{r}
tmap_mode("view")

airbnb0619_pte_map <- tm_shape(kde_airbnb0619SG_pte_bw_raster) + 
                  tm_raster("v", palette = "Purples", alpha = 0.7) +
                  tm_basemap("OpenStreetMap")

airbnb0721_pte_map <- tm_shape(kde_airbnb0721SG_pte_bw_raster) + 
                  tm_raster("v", palette = "Purples", alpha = 0.7) +
                  tm_basemap("OpenStreetMap")

tmap_arrange(airbnb0619_pte_map, airbnb0721_pte_map)

tmap_mode("plot")
```

Analysis: In 2019, only Chinatown have high density of private as shown in dark purple. In 2021, Kallang and Jalan Besar are new areas with high density 2021. Chinatown's private room density became lower than Kallang's private room density in 2021.

###### 6.1.1.3.2.2 Entire Home/Apt

The following code chunk is similar to 6.1.1.3.2.1.

```{r}
tmap_mode("view")

airbnb0619_ent_map <- tm_shape(kde_airbnb0619SG_ent_bw_raster) + 
                  tm_raster("v", palette = "Purples", alpha = 0.7) +
                  tm_basemap("OpenStreetMap")

airbnb0721_ent_map <- tm_shape(kde_airbnb0721SG_ent_bw_raster) + 
                  tm_raster("v", palette = "Purples", alpha = 0.7) +
                  tm_basemap("OpenStreetMap")

tmap_arrange(airbnb0619_ent_map, airbnb0721_ent_map)

tmap_mode("plot")
```

Analysis: In 2019, area with higher density of entire home room type (shown in darker purples) are Anson and Geylang. In 2021, areas with higher density of entire home room are Geylang, Chinatown, Whampoa, Anson and Katong. 

###### 6.1.1.3.2.3 Shared Room

The following code chunk is similar to 6.1.1.3.2.1.

```{r}
tmap_mode("view")

airbnb0619_sh_map <- tm_shape(kde_airbnb0619SG_sh_bw_raster) + 
                  tm_raster("v", palette = "Purples", alpha = 0.7) +
                  tm_basemap("OpenStreetMap")

airbnb0721_sh_map <- tm_shape(kde_airbnb0721SG_sh_bw_raster) + 
                  tm_raster("v", palette = "Purples", alpha = 0.7) +
                  tm_basemap("OpenStreetMap")

tmap_arrange(airbnb0619_sh_map, airbnb0721_sh_map)

tmap_mode("plot")
```

Analysis: In 2019, area with higher density of shared room type (shown in darker purples) are Clarke Quay. In 2021, areas with higher density of shared room are Rochor, Jalan Besar and Bencoolen.


###### 6.1.1.3.2.4 Hotel Room

The following code chunk is similar to 6.1.1.3.2.1. The only difference is that this chunk plots only one interactive map since Airbnb0619 do not have Hotel Room as room type.

```{r}
tmap_mode("view")

tm_shape(kde_airbnb0721SG_ht_bw_raster) + 
    tm_raster("v", palette = "Purples", alpha = 0.7) +
    tm_basemap("OpenStreetMap")

tmap_mode("plot")
```

Analysis: Hotel room is a new room type in 2021. Chinatown is the only area with highest density of Hotel room in 2021.

Overall, we can see that there are changes in each type of rooms, some area became denser and some became less dense from 2019 to 2021. We will focus specifically on Chinatown because the area is the most happening for majority of the room type and the area have the highest density in Hotel room type. Chinatown subzone is under Outram planning area and therefore we will focus on Outram area.

##### 6.1.1.3.3 KDE Map Comparison by Room type and Year (Specific Area)

###### 6.1.1.3.3.1 Extract and plot study area

1. The following code chunk extracts the target areas (Outram)

2. Convert Spatial Polygons Data Fraeme into generic SP format

3. Create owin object for the target area

```{r}
ot = mpsz[mpsz@data$PLN_AREA_N == "OUTRAM",]
ot_sp = as(ot, "SpatialPolygons")
ot_owin = as(ot_sp, "owin")

airbnb0619SG_pte_ot_ppp = airbnb0619_pte_ppp[ot_owin]
airbnb0619SG_ent_ot_ppp = airbnb0619_ent_ppp_jit[ot_owin]
airbnb0619SG_sh_ot_ppp = airbnb0619_sh_ppp_jit[ot_owin]
airbnb0721SG_pte_ot_ppp = airbnb0721_pte_ppp_jit[ot_owin]
airbnb0721SG_ent_ot_ppp = airbnb0721_ent_ppp_jit[ot_owin]
airbnb0721SG_sh_ot_ppp = airbnb0721_sh_ppp_jit[ot_owin]
airbnb0721SG_ht_ot_ppp = airbnb0721_ht_ppp_jit[ot_owin]
```

###### 6.1.1.3.3.2 Get bounding box and read osm

The following code chunk 

1. get bounding box of outram using getbb function of osmdata package

2. set the crs to 3414 using st_set_crs function of st package

3. read the OSM data using read_osm function of tmaptools

```{r}
ot_bb <- getbb("outram singapore", format_out = "sf_polygon")
st_set_crs(ot_bb, 3414)
ot_bb_osm <- read_osm(ot_bb, type = "osm")
```

###### 6.1.1.3.3.3 Calculate KDE

The following code chunk calculates KDE using density function of raster package. Note that we are using ppp in m.

```{r}
kde_airbnb0619_pte_ot_bw <- density(airbnb0619SG_pte_ot_ppp, 
                              sigma=bw.diggle, 
                               edge=TRUE, 
                               kernel="gaussian")

kde_airbnb0619_ent_ot_bw <- density(airbnb0619SG_ent_ot_ppp, 
                              sigma=bw.diggle, 
                               edge=TRUE, 
                               kernel="gaussian")

kde_airbnb0619_sh_ot_bw <- density(airbnb0619SG_sh_ot_ppp, 
                              sigma=bw.diggle, 
                               edge=TRUE, 
                               kernel="gaussian")

kde_airbnb0721_pte_ot_bw <- density(airbnb0721SG_pte_ot_ppp, 
                              sigma=bw.diggle, 
                               edge=TRUE, 
                               kernel="gaussian")

kde_airbnb0721_ent_ot_bw <- density(airbnb0721SG_ent_ot_ppp, 
                              sigma=bw.diggle, 
                               edge=TRUE, 
                               kernel="gaussian")

kde_airbnb0721_sh_ot_bw <- density(airbnb0721SG_sh_ot_ppp, 
                              sigma=bw.diggle, 
                               edge=TRUE, 
                               kernel="gaussian")

kde_airbnb0721_ht_ot_bw <- density(airbnb0721SG_ht_ot_ppp, 
                              sigma=bw.diggle, 
                               edge=TRUE, 
                               kernel="gaussian")
```

###### 6.1.1.3.3.4 Create RasterLayer object

1. The following code chunk converts KDE output into grid object using as.SpatialGridDataFrame.im function of maptools package

2. create a RasterLayer object using raster function of raster package

3. assign CRS of EPSG:3414 to the raster

```{r}
gridded_kde_airbnb0619_pte_ot_bw <- as.SpatialGridDataFrame.im(kde_airbnb0619_pte_ot_bw)
kde_airbnb0619_pte_ot_bw_raster <- raster(gridded_kde_airbnb0619_pte_ot_bw)
projection(kde_airbnb0619_pte_ot_bw_raster) <- CRS("+init=EPSG:3414")

gridded_kde_airbnb0619_ent_ot_bw <- as.SpatialGridDataFrame.im(kde_airbnb0619_ent_ot_bw)
kde_airbnb0619_ent_ot_bw_raster <- raster(gridded_kde_airbnb0619_ent_ot_bw)
projection(kde_airbnb0619_ent_ot_bw_raster) <- CRS("+init=EPSG:3414")

gridded_kde_airbnb0619_sh_ot_bw <- as.SpatialGridDataFrame.im(kde_airbnb0619_sh_ot_bw)
kde_airbnb0619_sh_ot_bw_raster <- raster(gridded_kde_airbnb0619_sh_ot_bw)
projection(kde_airbnb0619_sh_ot_bw_raster) <- CRS("+init=EPSG:3414")

gridded_kde_airbnb0721_pte_ot_bw <- as.SpatialGridDataFrame.im(kde_airbnb0721_pte_ot_bw)
kde_airbnb0721_pte_ot_bw_raster <- raster(gridded_kde_airbnb0721_pte_ot_bw)
projection(kde_airbnb0721_pte_ot_bw_raster) <- CRS("+init=EPSG:3414")

gridded_kde_airbnb0721_ent_ot_bw <- as.SpatialGridDataFrame.im(kde_airbnb0721_ent_ot_bw)
kde_airbnb0721_ent_ot_bw_raster <- raster(gridded_kde_airbnb0721_ent_ot_bw)
projection(kde_airbnb0721_ent_ot_bw_raster) <- CRS("+init=EPSG:3414")

gridded_kde_airbnb0721_sh_ot_bw <- as.SpatialGridDataFrame.im(kde_airbnb0721_sh_ot_bw)
kde_airbnb0721_sh_ot_bw_raster <- raster(gridded_kde_airbnb0721_sh_ot_bw)
projection(kde_airbnb0721_sh_ot_bw_raster) <- CRS("+init=EPSG:3414")

gridded_kde_airbnb0721_ht_ot_bw <- as.SpatialGridDataFrame.im(kde_airbnb0721_ht_ot_bw)
kde_airbnb0721_ht_ot_bw_raster <- raster(gridded_kde_airbnb0721_ht_ot_bw)
projection(kde_airbnb0721_ht_ot_bw_raster) <- CRS("+init=EPSG:3414")
```

###### 6.1.1.3.3.5 Private Room

1. The following code chunk create two maps

2. Each map is plotted with tm_shape of the osm and raster layer, tm_raster with setting of alpha = 0.7 that makes the raster layer slightly transparent so that the static osm can be seen, palette set to Purples

3. tmap_arrange to arrange the plot next to each other.

```{r}
tmap_mode("plot")
airbnb0619_pte_ot_map <- tm_shape(ot_bb_osm) +
                  tm_rgb() +
                  tm_shape(kde_airbnb0619_pte_ot_bw_raster) + 
                  tm_raster("v", palette = "Purples", alpha = 0.7) +
                  tm_layout(legend.position = c("right", "bottom"), legend.frame = TRUE)

airbnb0721_pte_ot_map <- tm_shape(ot_bb_osm) +
                  tm_rgb() + 
                  tm_shape(kde_airbnb0721_pte_ot_bw_raster) + 
                  tm_raster("v", palette = "Purples", alpha = 0.7) +
                  tm_layout(legend.position = c("right", "bottom"), legend.frame = TRUE)

tmap_arrange(airbnb0619_pte_ot_map, airbnb0721_pte_ot_map)
```

Analysis: From the static raster map, we can see that there are lesser purple area in 2021 which means that there are lesser private room Airbnb from 2021 as compared to 2019. 


###### 6.1.1.3.3.6 Entire Home/Apt

The following code chunk is similar to 6.1.1.3.3.5

```{r}
airbnb0619_ent_ot_map <- tm_shape(ot_bb_osm) +
                  tm_rgb() +
                  tm_shape(kde_airbnb0619_ent_ot_bw_raster) + 
                  tm_raster("v", palette = "Purples", alpha = 0.7) +
                  tm_layout(legend.position = c("right", "bottom"), legend.frame = TRUE)

airbnb0721_ent_ot_map <- tm_shape(ot_bb_osm) +
                  tm_rgb() + 
                  tm_shape(kde_airbnb0721_ent_ot_bw_raster) + 
                  tm_raster("v", palette = "Purples", alpha = 0.7) +
                  tm_layout(legend.position = c("right", "bottom"), legend.frame = TRUE)

tmap_arrange(airbnb0619_ent_ot_map, airbnb0721_ent_ot_map)
```

Analysis: From the static raster map, we can see that there are not much changes for the entire home Airbnb in this area from 2019 to 2021.


###### 6.1.1.3.3.7 Shared Room

The following code chunk is similar to 6.1.1.3.3.5

```{r}
airbnb0619_sh_ot_map <- tm_shape(ot_bb_osm) +
                  tm_rgb() +
                  tm_shape(kde_airbnb0619_sh_ot_bw_raster) + 
                  tm_raster("v", palette = "Purples", alpha = 0.7) +
                  tm_layout(legend.position = c("right", "bottom"), legend.frame = TRUE)

airbnb0721_sh_ot_map <- tm_shape(ot_bb_osm) +
                  tm_rgb() + 
                  tm_shape(kde_airbnb0721_sh_ot_bw_raster) + 
                  tm_raster("v", palette = "Purples", alpha = 0.7) +
                  tm_layout(legend.position = c("right", "bottom"), legend.frame = TRUE)

tmap_arrange(airbnb0619_sh_ot_map, airbnb0721_sh_ot_map)
```

Analysis: From the static raster map, we can see that there are lesser purple area in 2021 which means that there are lesser shared room Airbnb from 2021 as compared to 2019. 

###### 6.1.1.3.3.8 Hotel Room

The following code chunk is similar to 6.1.1.3.3.5, just that this code chunk plots one map.

```{r}
tm_shape(ot_bb_osm) +
  tm_rgb() + 
  tm_shape(kde_airbnb0721_ht_ot_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), legend.frame = TRUE)
```

Analysis: From the static raster map, we can see the new hotel room Airbnb in 2021.

## 6.2 Second-order Multi-type Spatial Point Patterns Analysis

### 6.2.1 Data Wrangling

#### 6.2.1.1 Convert into Factor data type

The following code chunk checks the data type of airbnb0619 and airbnb0619 SpatialPointsDataFrame

```{r}
str(airbnb0619)
```

```{r}
str(airbnb0721)
```

We can see that both are not in room_type are not in factor data type. 

The following code chunk converts room_type into a factor data type using as.factor functionc of base.

```{r}
airbnb0619@data$room_type <- as.factor(airbnb0619@data$room_type)
str(airbnb0619)
```

```{r}
airbnb0721@data$room_type <- as.factor(airbnb0721@data$room_type)
str(airbnb0721)
```

We can see that the data type for room_type are now Factor above.

#### 6.2.1.2 Converting the SpatialPointsDataFrame into ppp format

1. The following code chunk converts the SpatialPointsDataFrame into ppp format using as(x,"ppp") function
2. marks room_type using marks function of spatstat package
3. plots the ppp using plot function

```{r}
airbnb0619_ppp <- as(airbnb0619, "ppp")
marks(airbnb0619_ppp) <- airbnb0619_ppp$marks$room_type
plot(airbnb0619_ppp)
```

From the plot above, we can see that there are three room types in 2019. They are Entire home/apt, Private room and Shared room.

```{r}
airbnb0721_ppp <- as(airbnb0721, "ppp")
marks(airbnb0721_ppp) <- airbnb0721_ppp$marks$room_type
plot(airbnb0721_ppp)
```

From the plot above, we can see that there are four room types in 2021. They are Entire home/apt, Hotel room, Private room and Shared room.

#### 6.2.1.3 Examine summary statistics

The following code chunk examines the summary statistics of ppp.

```{r}
summary(airbnb0619_ppp)
```

From the statistic above, we can see that Entire home/apt made up 51% of Airbnb in Outram in 2019, followed by Private room with 43% and Shared room with 5%. 

```{r}
summary(airbnb0721_ppp)
```

From the statistic above, we can see that Private room Airbnb in Outram in 2021 made up the highest with 48%, followed by Entire home/apt made up 43%, Hotel and Shared room with about 4% each. The number of Entire home/apt decrease significantly from 4264 in 2019 to 1837 in 2021. The number of Airbnb in Outram generally decreased as a whole, except that there are a new hotel room type.

#### 6.2.1.4 Handling Duplicates

The following code chunk handles duplicates using jitter method with rjitter functions of spatstat package.

```{r}
airbnb0619rt_ppp_jit <- rjitter(airbnb0619_ppp, retry=TRUE, nsim=1, drop=TRUE)
airbnb0721rt_ppp_jit <- rjitter(airbnb0721_ppp, retry=TRUE, nsim=1, drop=TRUE)
```

The following code chunk checks for any duplicates

```{r}
any(duplicated(airbnb0619rt_ppp_jit))
```

```{r}
any(duplicated(airbnb0721rt_ppp_jit))
```

There are no duplicates after jittering.

#### 6.2.1.5 Extract study area and combine with Airbnb

The following code chunk extract the study area and plots it to see if it is the correct area.

```{r}
ot = mpsz[mpsz@data$PLN_AREA_N == "OUTRAM",]
plot(ot, main = "Outram")
```

The following code chunk converts the SpatialPolygonsDataFrame into generic sp format and create the owin object of that area.

```{r}
ot_sp = as(ot, "SpatialPolygons")
ot_owin = as(ot_sp, "owin")
```

The following code chunk combines the airbnb points with study area

```{r}
airbnb0619rt_ot_ppp = airbnb0619rt_ppp_jit[ot_owin]
airbnb0721rt_ot_ppp = airbnb0721rt_ppp_jit[ot_owin]
```

#### 6.2.1.6 Analysing Marked Point Patterns in km

The following code chunk plots the KDE map of each room type in 2019.

```{r}
plot(density(split(rescale(airbnb0619rt_ot_ppp, 1000))))
```

From the plot above, we can see that all room types are denser at the central area of Outram in 2019.

The following code chunk plots the KDE map of each room type in 2019.

```{r fig.height=8, fig.width=8}
plot(density(split(rescale(airbnb0721rt_ot_ppp, 1000))))
```

From the plot above, we can see that all room types are denser at the central area of Outram in 2021.

The following code chunk reveals the density of each Airbnb room type using intensity function of spatstat package,

```{r}
intensity(rescale(airbnb0619rt_ot_ppp, 1000))
```

From the statistics above, Private room have the highest density of about 175 units per square kilometer. Entire home/apt have a density of about 118 units per square kilometer. Shared room have a density of about 49 units per square kilometer.

```{r}
intensity(rescale(airbnb0721rt_ot_ppp, 1000))
```

From the statistics above, Private room have the highest density of about 134 units per square kilometer. Entire home/apt have a density of about 85 units per square kilometer. Hotel room have a density of about 53 units per square kilometer. Shared room have a density of about 8 units per square kilometer.

### 6.2.2 Cross L-Function

Cross-type L-function computes the estimate of the cross-type K-function, and then applies the square root transformation. We will be looking at the relationship of different room types Airbnb located in the study area (Out), in 2019 and 2021. We will set.seed at each code chunk so that the output will be the same.

#### 6.2.2.1 Relationship of Private Room and Shared Room Airbnb in 2019

##### 6.2.2.1.1 Compute Cross L-function

The following code chunk computes Cross L-function using Lcross() of spatstat package.

```{r}
set.seed(62211)
airbnb0619_ptsh_Lcross <- Lcross(airbnb0619rt_ot_ppp, i="Private room", j="Shared room", correction='border')
plot(airbnb0619_ptsh_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

Analysis: The plot above reveals that there is a sign that the marked spatial point events are not independent spatially from distance 0 to 150m as the L(r) is above 0. From 150 meter and above, there is a sign that the marked spatial point events are independent spatially as the L(r) is below 0. Hypothesis test is required to confirm the observation statistically.

##### 6.2.2.1.2 Performing CSR testing on the Cross L-Function

Hypothesis:

H0 = The distribution of Private room Airbnb and Shared room Airbnb in 2019 are spatially independent.

H1= The distribution of Private room Airbnb and Shared room Airbnb in 2019 are NOT at spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

The following code chunk performs CSR test by using envelope() of spatstat package will be used.

```{r}
set.seed(62212)
airbnb0619_ptsh_Lcross.csr <- envelope(airbnb0619rt_ot_ppp, Lcross, i="Private room", j="Shared room", correction='border', nsim=999)
```

The following code chunk plots the Cross L-Function

```{r eval=FALSE}
plot(airbnb0619_ptsh_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"

Lcsr_df <- as.data.frame(airbnb0619_ptsh_Lcross.csr)

colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)

text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"

# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

Analysis: The plot above shows that the observed L(r) line is below L(theo) from 160m onwards and is beyond the lower confidence envelope which means spatial dispersion for that distance is statistically significant. Hence, we do not reject the null hypothesis that the distribution of Private room Airbnb and Shared room Airbnb in 2019 are spatially independent at 99.9% confident interval.

#### 6.2.2.2 Relationship of Private Room and Entire Home/Apt Airbnb in 2019

##### 6.2.2.2.1 Compute Cross L-function

The following code chunk computes Cross L-function using Lcross() of spatstat package.

```{r}
set.seed(62221)
airbnb0619_ptent_Lcross <- Lcross(airbnb0619rt_ot_ppp, i="Private room", j="Entire home/apt", correction='border')
plot(airbnb0619_ptent_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

Analysis: The plot above reveals that there is a sign that the marked spatial point events are not independent spatially from distance 0 to 140m, and 180 to 190m as the L(r) is above 0. From 140 to 180m, and 190m and above, there is a sign that the marked spatial point events are independent spatially as the L(r) is below 0. Hypothesis test is required to confirm the observation statistically.

##### 6.2.2.2.2 Performing CSR testing on the Cross L-Function

Hypothesis:

H0 = The distribution of Private room Airbnb and Entire home/apt Airbnb in 2019 are spatially independent.

H1= The distribution of Private room Airbnb and and Entire home/apt Airbnb in 2019 are NOT at spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

The following code chunk performs CSR test by using envelope() of spatstat package will be used.

```{r}
set.seed(62222)
airbnb0619_ptent_Lcross.csr <- envelope(airbnb0619rt_ot_ppp, Lcross, i="Private room", j="Entire home/apt", correction='border', nsim=999)
```

The following code chunk plots the Cross L-Function

```{r eval=FALSE}
plot(airbnb0619_ptent_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"

Lcsr_df <- as.data.frame(airbnb0619_ptent_Lcross.csr)

colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)

text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"

# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

Analysis: The plot above shows that the observed L(r) line is below L(theo) from 190m onwards and is within the lower confidence envelope which means spatial dispersion for that distance is statistically not significant. Even though the observed L(r) is near 0, the ending observed r is -0.75 at 195m. Hence, we reject the null hypothesis that the distribution of Private room Airbnb and Entire home/apt Airbnb in 2019 are spatially independent at 99.9% confident interval.

#### 6.2.2.3 Relationship of Shared Room and Entire Home/Apt Airbnb in 2019

##### 6.2.2.3.1 Compute Cross L-function

The following code chunk computes Cross L-function using Lcross() of spatstat package.

```{r}
set.seed(62231)
airbnb0619_shent_Lcross <- Lcross(airbnb0619rt_ot_ppp, i="Shared room", j="Entire home/apt", correction='border')
plot(airbnb0619_shent_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

Analysis: The plot above reveals that there is a sign that the marked spatial point events are not independent spatially from distance 0 to 160m as the L(r) is above 0. From 160 meter and above, there is a sign that the marked spatial point events are independent spatially as the L(r) is below 0. Hypothesis test is required to confirm the observation statistically.

##### 6.2.2.3.2 Performing CSR testing on the Cross L-Function

Hypothesis:

H0 = The distribution of Shared room Airbnb and Entire home/apt Airbnb in 2019 are spatially independent.

H1= The distribution of Shared room Airbnb and and Entire home/apt Airbnb in 2019 are NOT at spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

The following code chunk performs CSR test by using envelope() of spatstat package will be used.

```{r}
set.seed(62232)
airbnb0619_shent_Lcross.csr <- envelope(airbnb0619rt_ot_ppp, Lcross, i="Shared room", j="Entire home/apt", correction='border', nsim=999)
```

The following code chunk plots the Cross L-Function

```{r eval=FALSE}
plot(airbnb0619_shent_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"

Lcsr_df <- as.data.frame(airbnb0619_shent_Lcross.csr)

colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)

text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"

# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

Analysis: The plot above shows that the observed L(r) line is below L(theo) from 160m onwards and is beyond the lower confidence envelope which means spatial dispersion for that distance is statistically significant. Hence, we do not reject the null hypothesis that the distribution of Shared room Airbnb and Entire home/apt Airbnb in 2019 are spatially independent at 99.9% confident interval.

#### 6.2.2.4 Relationship of Private Room and Shared Room Airbnb in 2021

##### 6.2.2.4.1 Compute Cross L-function

The following code chunk computes Cross L-function using Lcross() of spatstat package.

```{r}
set.seed(62241)
airbnb0721_ptsh_Lcross <- Lcross(airbnb0721rt_ot_ppp, i="Private room", j="Shared room", correction='border')
plot(airbnb0721_ptsh_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

Analysis: The plot above reveals that there is a sign that the marked spatial point events are not independent spatially from distance 10 to 100m, and 120 to 200m as the L(r) is above 0. From 0 to 10m, 100 to 120m, and 200 meter and above, there is a sign that the marked spatial point events are independent spatially as the L(r) is below 0. Hypothesis test is required to confirm the observation statistically.

##### 6.2.2.4.2 Performing CSR testing on the Cross L-Function

Hypothesis:

H0 = The distribution of Private Room Airbnb and Shared Room Airbnb in 2021 are spatially independent.

H1= The distribution of Private Room Airbnb and Shared Room Airbnb in 2021 are NOT at spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

The following code chunk performs CSR test by using envelope() of spatstat package will be used.

```{r}
set.seed(62242)
airbnb0721_ptsh_Lcross.csr <- envelope(airbnb0721rt_ot_ppp, Lcross, i="Private room", j="Shared room", correction='border', nsim=999)
```

The following code chunk plots the Cross L-Function

```{r eval=FALSE}
plot(airbnb0721_ptsh_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"

Lcsr_df <- as.data.frame(airbnb0721_ptsh_Lcross.csr)

colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)

text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"

# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

Analysis: The plot above shows that the observed L(r) line is below L(theo) from 200m onwards and is within the lower confidence envelope which means spatial dispersion for that distance is statistically not significant. Hence, we reject the null hypothesis that the distribution of Private Room Airbnb and Shared Room Airbnb in 2021 are spatially independent at 99.9% confident interval.

#### 6.2.2.5 Relationship of Private Room and Entire Home/Apt Airbnb in 2021

##### 6.2.2.5.1 Compute Cross L-function

The following code chunk computes Cross L-function using Lcross() of spatstat package.

```{r}
set.seed(62251)
airbnb0721_ptent_Lcross <- Lcross(airbnb0721rt_ot_ppp, i="Private room", j="Entire home/apt", correction='border')
plot(airbnb0721_ptent_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

Analysis: The plot above reveals that there is a sign that the marked spatial point events are not independent spatially from distance 0 to 150m as the L(r) is above 0. From 150 meter and above, there is a sign that the marked spatial point events are independent spatially as the L(r) is below 0. Hypothesis test is required to confirm the observation statistically.

##### 6.2.2.5.2 Performing CSR testing on the Cross L-Function

Hypothesis:

H0 = The distribution of Private Room Airbnb and Entire Home/Apt Airbnb in 2021 are spatially independent.

H1= The distribution of Private Room Airbnb and Entire Home/Apt Airbnb in 2021 are NOT at spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

The following code chunk performs CSR test by using envelope() of spatstat package will be used.

```{r}
set.seed(62252)
airbnb0721_ptent_Lcross.csr <- envelope(airbnb0721rt_ot_ppp, Lcross, i="Private room", j="Entire home/apt", correction='border', nsim=999)
```

The following code chunk plots the Cross L-Function

```{r eval=FALSE}
plot(airbnb0721_ptent_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"

Lcsr_df <- as.data.frame(airbnb0721_ptent_Lcross.csr)

colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)

text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"

# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

Analysis: The plot above shows that the observed L(r) line is below L(theo) from about 150m onwards and is beyond the lower confidence envelope which means spatial dispersion for that distance is statistically significant. Hence, we do not reject the null hypothesis that the distribution of Private Room Airbnb and Entire Home/Apt Airbnb in 2021 are spatially independent at 99.9% confident interval.

#### 6.2.2.6 Relationship of Private Room and Hotel Room Airbnb in 2021

##### 6.2.2.6.1 Compute Cross L-function

The following code chunk computes Cross L-function using Lcross() of spatstat package.

```{r}
set.seed(62261)
airbnb0721_ptht_Lcross <- Lcross(airbnb0721rt_ot_ppp, i="Private room", j="Hotel room", correction='border')
plot(airbnb0721_ptht_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

Analysis: The plot above reveals that there is a sign that the marked spatial point events are not independent spatially from distance 0 to 150m as the L(r) is above 0. From 150 meter and above, there is a sign that the marked spatial point events are independent spatially as the L(r) is below 0. Hypothesis test is required to confirm the observation statistically.

##### 6.2.2.6.2 Performing CSR testing on the Cross L-Function

Hypothesis:

H0 = The distribution of Private Room Airbnb and Hotel Room Airbnb in 2021 are spatially independent.

H1= The distribution of Private Room Airbnb and Hotel Room Airbnb in 2021 are NOT at spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

The following code chunk performs CSR test by using envelope() of spatstat package will be used.

```{r}
set.seed(62262)
airbnb0721_ptht_Lcross.csr <- envelope(airbnb0721rt_ot_ppp, Lcross, i="Private room", j="Hotel room", correction='border', nsim=999)
```

The following code chunk plots the Cross L-Function

```{r eval=FALSE}
plot(airbnb0721_ptht_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"

Lcsr_df <- as.data.frame(airbnb0721_ptht_Lcross.csr)

colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)

text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"

# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

Analysis: The plot above shows that the observed L(r) line is below L(theo) from about 150m onwards and is beyond the lower confidence envelope which means spatial dispersion for that distance is statistically significant. Hence, we do not reject the null hypothesis that the distribution of Private Room Airbnb and Hotel Room Airbnb in 2021 are spatially independent at 99.9% confident interval.

#### 6.2.2.7 Relationship of Shared Room and Entire Home/Apt Airbnb in 2021

##### 6.2.2.7.1 Compute Cross L-function

The following code chunk computes Cross L-function using Lcross() of spatstat package.

```{r}
set.seed(62271)
airbnb0721_shent_Lcross <- Lcross(airbnb0721rt_ot_ppp, i="Shared room", j="Entire home/apt", correction='border')
plot(airbnb0721_shent_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

Analysis: The plot above reveals that there is a sign that the marked spatial point events are not independent spatially from distance 10 to 120m as the L(r) is above 0. From 0 - 10m, and 120 meter and above, there is a sign that the marked spatial point events are independent spatially as the L(r) is below 0. Hypothesis test is required to confirm the observation statistically.

##### 6.2.2.7.2 Performing CSR testing on the Cross L-Function

Hypothesis:

H0 = The distribution of Shared Room Airbnb and Entire home/apt Airbnb in 2021 are spatially independent.

H1= The distribution of Shared Room Airbnb and Entire home/apt Airbnb in 2021 are NOT at spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

The following code chunk performs CSR test by using envelope() of spatstat package will be used.

```{r}
set.seed(62272)
airbnb0721_shent_Lcross.csr <- envelope(airbnb0721rt_ot_ppp, Lcross, i="Shared room", j="Entire home/apt", correction='border', nsim=999)
```

The following code chunk plots the Cross L-Function

```{r eval=FALSE}
plot(airbnb0721_shent_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"

Lcsr_df <- as.data.frame(airbnb0721_shent_Lcross.csr)

colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)

text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"

# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

Analysis: The plot above shows that the observed L(r) line is above L(theo) from about 10 to 120m and is above the higher confidence envelope which means spatial clustering for that distance is statistically significant. Hence, we reject the null hypothesis that the distribution of Shared Room Airbnb and Entire home/apt Airbnb in 2021 are spatially independent at 99.9% confident interval.

#### 6.2.2.8 Relationship of Shared Room and Hotel Room Airbnb in 2021

##### 6.2.2.8.1 Compute Cross L-function

The following code chunk computes Cross L-function using Lcross() of spatstat package.

```{r}
set.seed(62281)
airbnb0721_shht_Lcross <- Lcross(airbnb0721rt_ot_ppp, i="Shared room", j="Hotel room", correction='border')
plot(airbnb0721_shht_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

Analysis: The plot above reveals that there is a sign that the marked spatial point events are independent spatially from distance 0 to 10m as the L(r) is below 0. From 10 meter and above, there is a sign that the marked spatial point events are not independent spatially as the L(r) is above 0. Hypothesis test is required to confirm the observation statistically.

##### 6.2.2.8.2 Performing CSR testing on the Cross L-Function

Hypothesis:

H0 = The distribution of Shared Room Airbnb and Hotel Room Airbnb in 2021 are spatially independent.

H1= The distribution of Shared Room Airbnb and Hotel Room Airbnb in 2021 are NOT at spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

The following code chunk performs CSR test by using envelope() of spatstat package will be used.

```{r}
set.seed(62282)
airbnb0721_shht_Lcross.csr <- envelope(airbnb0721rt_ot_ppp, Lcross, i="Shared room", j="Hotel room", correction='border', nsim=999)
```

The following code chunk plots the Cross L-Function

```{r eval=FALSE}
plot(airbnb0721_shht_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"

Lcsr_df <- as.data.frame(airbnb0721_shht_Lcross.csr)

colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)

text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"

# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

Analysis: The plot above shows that the observed L(r) line is above L(theo) from around 10m ownwards and is above the higher confidence envelope which means spatial clustering for that distance is statistically significant. Hence, we reject the null hypothesis that the distribution of Shared Room Airbnb and Hotel Room Airbnb in 2021 are spatially independent at 99.9% confident interval.

#### 6.2.2.9 Relationship of Entire Home/Apt and Hotel Room Airbnb in 2021

##### 6.2.2.9.1 Compute Cross L-function

The following code chunk computes Cross L-function using Lcross() of spatstat package.

```{r}
set.seed(62291)
airbnb0721_entht_Lcross <- Lcross(airbnb0721rt_ot_ppp, i="Entire home/apt", j="Hotel room", correction='border')
plot(airbnb0721_entht_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

Analysis: The plot above reveals that there is a sign that the marked spatial point events are not independent spatially from distance 5 to 150m as the L(r) is above 0. From 0 to 5 meter, and 150m and above, there is a sign that the marked spatial point events are independent spatially as the L(r) is below 0. Hypothesis test is required to confirm the observation statistically.

##### 6.2.2.9.2 Performing CSR testing on the Cross L-Function

Hypothesis:

H0 = The distribution of Entire home/apt Airbnb and Hotel Room Airbnb in 2021 are spatially independent.

H1= The distribution of Entire home/apt Airbnb and Hotel Room Airbnb in 2021 are NOT at spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

The following code chunk performs CSR test by using envelope() of spatstat package will be used.

```{r}
set.seed(62292)
airbnb0721_entht_Lcross.csr <- envelope(airbnb0721rt_ot_ppp, Lcross, i="Entire home/apt", j="Hotel room", correction='border', nsim=999)
```


The following code chunk plots the Cross L-Function

```{r eval=FALSE}
plot(airbnb0721_entht_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"

Lcsr_df <- as.data.frame(airbnb0721_entht_Lcross.csr)

colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)

text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"

# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

Analysis: The plot above shows that the observed L(r) line is below L(theo) from about 150m onwards and is within the lower confidence envelope which means spatial dispersion for that distance is not statistically significant. Hence, we reject the null hypothesis that the distribution of Entire home/apt Airbnb and Hotel Room Airbnb in 2021 are spatially independent at 99.9% confident interval.
